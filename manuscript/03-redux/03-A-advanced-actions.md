## Продвинутые действия

Вы узнали о действиях в предыдущей главе. Однако есть более мелкие детали, которые я хочу осветить в этой главе. То же самое относится и к редукторам. Обе концепции будут рассмотрены в следующих главах более подробно. Поэтому требуется, чтобы вы чувствовали себя уверенно в отношении уроков из предыдущей главы. Не все следующие уроки являются обязательными для написания приложений с Redux, но они учат передовым методам и распространенным шаблонам использования. При разработке приложении большего размера вы хотели бы знать об этих темах.

### Минимальная полезная нагрузка действия

Вы помните действие из предыдущей главы, в которой был добавлен элемент todo? Это было что-то вроде следующего:

{title="Code Playground",lang="javascript"}
~~~~~~~~
{
  type: 'TODO_ADD',
  todo: { id: '0', name: 'learn redux', completed: false },
}
~~~~~~~~

Как видите, свойство `completed` определено как ложное логическое значение. Кроме того, вы видели, что действие и редуктор из предыдущей главы работали при этих условиях. Однако в Redux практическое правило сводить полезную нагрузку к минимуму.

В этом примере, когда вы хотите добавить задачу в приложение Todo, ему потребуется как минимум уникальный идентификатор и имя задачи. Но свойство `completed` не нужно. Предполагается, что все задачи, добавленные в магазин, будут неполными в начале. В приложении Todo не имеет смысла добавлять завершенные задачи, не так ли? Следовательно, не действие будет заботиться о свойстве `completed`, а редуктор.

Вместо того, чтобы просто передавать весь объект задачи из действия в список задач в вашей функции редуктора:

{title="Code Playground",lang="javascript"}
~~~~~~~~
function applyAddTodo(state, action) {
  return state.concat(action.todo);
}
~~~~~~~~

Вы можете добавить свойство `complete` как жестко закодированное свойство к вашей функции редуктора:

{title="Code Playground",lang="javascript"}
~~~~~~~~
function applyAddTodo(state, action) {
  const todo = Object.assign({}, action.todo, { completed: false });
  return state.concat(todo);
}
~~~~~~~~

Наконец, вы можете не включать его в полезной нагрузке действия:

{title="Code Playground",lang="javascript"}
~~~~~~~~
{
  type: 'TODO_ADD',
  todo: { id: '0', name: 'learn redux' },
}
~~~~~~~~

Теперь вы определяете только необходимую полезную нагрузку в действии, чтобы добавить элемент todo в список в хранилище. Тем не менее, если в какой-то момент приложение Todo решит добавить незавершенные задачи в первую очередь, вы можете снова добавить его в действие и оставить его вне редуктора. В конечном счете, сведение полезной нагрузки в действии к минимуму должно быть лучшей практикой в Redux.

### Тип действия

Действия оцениваются в редукторах по типу. Тип действия является связующим звеном между обеими частями, хотя действия и редукторы могут быть определены независимо. Чтобы сделать приложение более устойчивым, вы должны извлечь тип действия как переменную. В противном случае вы можете столкнуться с опечатками, когда действие никогда не достигает редуктора, потому что вы ошиблись в нем.

{title="Code Playground",lang="javascript"}
~~~~~~~~
# leanpub-start-insert
const TODO_ADD = 'TODO_ADD';
const TODO_TOGGLE = 'TODO_TOGGLE';
# leanpub-end-insert

const action = {
# leanpub-start-insert
  type: TODO_ADD,
# leanpub-end-insert
  todo: { id: '0', name: 'learn redux' },
};

const toggleTodoAction = {
# leanpub-start-insert
  type: TODO_TOGGLE,
# leanpub-end-insert
  todo: { id: '0' },
};

function reducer(state, action) {
  switch(action.type) {
# leanpub-start-insert
    case TODO_ADD : {
# leanpub-end-insert
      return applyAddTodo(state, action);
    }
# leanpub-start-insert
    case TODO_TOGGLE : {
# leanpub-end-insert
      return applyToggleTodo(state, action);
    }
    default : return state;
  }
}
~~~~~~~~

Есть еще одно преимущество в извлечении типа действия как переменной. Поскольку действие, редуктор и тип действия слабо связаны, вы можете определить их в отдельных файлах. Вам нужно будет только импортировать тип действия, чтобы использовать их только в определенных действиях и редукторах. В конце концов, типы действий можно использовать и в нескольких редукторах. Этот вариант использования будет рассмотрен в другой главе, когда речь идет о продвинутых редукторах.

### Создатели действий

Создатели действий добавляют еще один слой, что часто приводит к путанице при изучении Redux. Создатели действий не являются обязательными, но ими удобно пользоваться. Итак, вы отправили действие как простой объект действия:

{title="Code Playground",lang="javascript"}
~~~~~~~~
const TODO_ADD = 'TODO_ADD';

store.dispatch({
  type: TODO_ADD,
  todo: { id: '0', name: 'learn redux' },
});
~~~~~~~~

Создатели действий инкапсулируют действие с его типом действия и необязательной полезной нагрузкой в многократно используемую функцию. Имея функцию для вашего действия, вы получаете гибкость для передачи любой полезной нагрузки в качестве аргументов. В конце концов, это только чистые функции, которые возвращают объект.

{title="Code Playground",lang="javascript"}
~~~~~~~~
function doAddTodo(id, name) {
  return {
    type: TODO_ADD,
    todo: { id, name },
  };
}
~~~~~~~~

Теперь вы можете использовать создатель действия, вызывая его как функцию в вашем методе отправки:

{title="Code Playground",lang="javascript"}
~~~~~~~~
store.dispatch(doAddTodo('0', 'learn redux'));
~~~~~~~~

Создатели действий возвращают простое действие (объект). Еще раз, это не обязательно использовать их, но это добавляет удобство и делает ваш код более читабельным в долгосрочной перспективе. Кроме того, вы можете самостоятельно тестировать создателей действий как функции. Наконец, что не менее важно, эти создатели действий остаются многоразовыми, потому что они являются функциями.

### Необязательная полезная нагрузка

В книге было упомянуто ранее, что действия не должны иметь полезную нагрузку. Требуется только тип действия. Например, представьте, что вы хотите залогиниться в свое приложение Todo. Вам нужно открыть модальное окно, где вы можете ввести свои учетные данные: адрес электронной почты и пароль. Вам не понадобится полезная нагрузка для вашего действия, чтобы открыть модальное окно. Вам нужно только сигнализировать, что состояние модального окна должно быть сохранено как «открытое», отправляя действие.

{title="Code Playground",lang="javascript"}
~~~~~~~~
{
  type: 'LOGIN_MODAL_OPEN',
}
~~~~~~~~

Редуктор позаботится об этом и установит для логического состояния `isLoginModalOpen` значение true. Хотя полезно знать, что полезная нагрузка не является обязательной в действиях, последний пример может привести к плохой практике. Потому, что вам понадобится второе действие, чтобы снова закрыть модальное окно:

{title="Code Playground",lang="javascript"}
~~~~~~~~
{
  type: 'LOGIN_MODAL_CLOSE',
}
~~~~~~~~

Снова редуктор установил бы логическое значение `isLoginModalOpen` в состоянии в false. Это многословно, потому что вам уже нужны два действия, чтобы изменить только одно свойство в состоянии. Продуманно планируя свои действия, вы избегаете этих плохих практик и держите свои действия на более высоком уровне абстракции. Если бы вы использовали дополнительную полезную нагрузку для действия, вы могли бы решить проблему входа в систему только в одном действии вместо двух. Свойство isLoginModalOpen будет динамически передаваться в действии, а не жестко кодироваться в редукторе.

{title="Code Playground",lang="javascript"}
~~~~~~~~
{
  type: 'LOGIN_MODAL_TOGGLE',
  isLoginModalOpen: true,
}
~~~~~~~~

Используя создателя действий, полезная нагрузка может быть передана в качестве аргументов и, таким образом, остается гибкой. После этого требуется только одно действие вместо двух.

{title="Code Playground",lang="javascript"}
~~~~~~~~
function doToggleLoginModal(open) {
  return {
    type: 'LOGIN_MODAL_TOGGLE',
    isLoginModalOpen: open,
  };
}
~~~~~~~~

В Redux действия всегда должны пытаться оставаться на абстрактном уровне. В противном случае вы получите дубликаты и избыточные действия. Тем не менее, пока не слишком переживайте по этому поводу. Это будет объяснено более подробно в другой главе этой книги, посвященной командам и событиям.

### Структура полезной нагрузки

Снова вы столкнетесь с лучшей практикой, которая не обязательна в Redux. До сих пор полезная нагрузка в действиях была сброшена без особых раздумий. Теперь представьте действие, которое имеет большую полезную нагрузку, чем простое задание. Например, полезная нагрузка действия должна уточнить, кому назначена задача.

{title="Code Playground",lang="javascript"}
~~~~~~~~
{
  type: 'TODO_ADD_ASSIGNED',
  todo: { id: '0', name: 'learn redux' },
  assignedTo: { id: '99' name: 'Robin' },
}
~~~~~~~~

Свойства будут складываться горизонтально в объекте, скрывая наиболее важное свойство - тип действия - когда их становится слишком много. Следовательно, вы должны рассматривать тип действия и полезную нагрузку на одном уровне, но вкладывать саму полезную нагрузку на один уровень глубже как два абстрактных свойства.

{title="Code Playground",lang="javascript"}
~~~~~~~~
{
  type: 'TODO_ADD_ASSIGNED',
  payload: {
    todo: { id: '0', name: 'learn redux' },
    assignedTo: { id: '99' name: 'Robin' },
  },
}
~~~~~~~~

Рефакторинг гарантирует, что тип и полезная нагрузка видны с первого взгляда. Как уже говорилось, это не обязательно, и часто добавляет больше сложности. Но в более крупных приложениях ваши создатели действий становятся более читабельными.

### Практика: Redux с продвинутыми действиями

Давайте снова окунемся в игровую площадку Redux с приобретенными знаниями о действиях. Вы можете снова взять [проект JS Bin, который вы делали в предыдущей главе](https://jsbin.com/kopohur/28/edit?html,js,console). Проект будет использоваться для демонстрации продвинутых действий. Вы можете попробовать это самостоятельно. В противном случае следующая часть проведет вас через рефакторинг.

Минимальная полезная нагрузка - быстрый рефакторинг. Вы можете опустить свойство `completed` в действии и добавить его в функциональность редуктора.

{title="Code Playground",lang="javascript"}
~~~~~~~~
function applyAddTodo(state, action) {
# leanpub-start-insert
  const todo = Object.assign({}, action.todo, { completed: false });
  return state.concat(todo);
# leanpub-end-insert
}

...

store.dispatch({
  type: 'TODO_ADD',
# leanpub-start-insert
  todo: { id: '0', name: 'learn redux' },
# leanpub-end-insert
});

store.dispatch({
  type: 'TODO_ADD',
# leanpub-start-insert
  todo: { id: '1', name: 'learn mobx' },
# leanpub-end-insert
});
~~~~~~~~

Следующим шагом является извлечение типов действий из действий и редуктора. Они должны быть определены как переменные и, следовательно, могут быть заменены в редукторе.

{title="Code Playground",lang="javascript"}
~~~~~~~~
const TODO_ADD = 'TODO_ADD';
const TODO_TOGGLE = 'TODO_TOGGLE';

function reducer(state, action) {
  switch(action.type) {
# leanpub-start-insert
    case TODO_ADD : {
# leanpub-end-insert
      return applyAddTodo(state, action);
    }
# leanpub-start-insert
    case TODO_TOGGLE : {
# leanpub-end-insert
      return applyToggleTodo(state, action);
    }
    default : return state;
  }
}
~~~~~~~~

Кроме того, вы можете использовать переменные и в отправленных действиях.

{title="Code Playground",lang="javascript"}
~~~~~~~~
store.dispatch({
# leanpub-start-insert
  type: TODO_ADD,
# leanpub-end-insert
  todo: { id: '0', name: 'learn redux' },
});

store.dispatch({
# leanpub-start-insert
  type: 'TODO_ADD',
# leanpub-end-insert
  todo: { id: '1', name: 'learn mobx' },
});

store.dispatch({
# leanpub-start-insert
  type: TODO_TOGGLE,
# leanpub-end-insert
  todo: { id: '0' },
});
~~~~~~~~

На следующем шаге вы можете представить создателей действий своему приложению Todo. Сначала определите их как функции:

{title="Code Playground",lang="javascript"}
~~~~~~~~
function doAddTodo(id, name) {
  return {
    type: TODO_ADD,
    todo: { id, name },
  };
}

function doToggleTodo(id) {
  return {
    type: TODO_TOGGLE,
    todo: { id },
  };
}
~~~~~~~~

Во-вторых, используйте их в своих функциях отправления для возврата объектов действия:

{title="Code Playground",lang="javascript"}
~~~~~~~~
store.dispatch(doAddTodo('0', 'learn redux'));
store.dispatch(doAddTodo('1', 'learn mobx'));
store.dispatch(doToggleTodo('0'));
~~~~~~~~

В этой главе были еще две продвинутые темы о действиях: дополнительная полезная нагрузка и структура полезной нагрузки. Первая тема не будет применяться в текущем приложении. Каждое действие должно иметь полезную нагрузку в данном сценарии. Вторая тема может быть применена. Однако на данный момент полезная нагрузка слишком мала и, следовательно, не требует реструктуризации с использованием свойства промежуточной полезной нагрузки.

[Финальное приложение Todo можно найти в этом JS Bin](https://jsbin.com/kopohur/29/edit?html,js,console). Вы можете провести дальнейшие эксперименты с ним, прежде чем перейти к следующей главе.
