## Основы Redux

На [официальном сайте Redux](http://redux.js.org) говорится: *"Redux - это предсказуемый контейнер состояний для JavaScript приложений."*. Он может использоваться автономно или совместно с библиотеками, такими как React и Angular, для управления состоянием в JavaScript приложениях.

Redux принял несколько ограничений из архитектуры Flux, но не все из них. Он имеет Actions (действия), которые инкапсулируют информацию для актуального обновления состояния. У него есть Store (хранилище), чтобы чтобы сохранять состояние. Store (хранилище) имеется в единственном числе. Таким образом, не существует нескольких Stores (хранилищ), как это было в архитектуре Flux. Кроме того, нет единого Dispatcher (диспетчера). Вместо этого Redux использует несколько Reducers (редукторов). По сути, Reducers (редукторы) получают информацию из действий и «переводят» информацию в новое состояние вместе со старым состоянием, которое хранится в Store (хранилище). Когда состояние в Store (хранилище) изменяется, View (представление) может действовать, подписавшись на Store (хранилище).

{title="Concept Playground",lang="text"}
~~~~~~~~
View -> Action -> Reducer(s) -> Store -> View
~~~~~~~~

Так почему он называется Redux? Потому что он сочетает в себе два слова Reducer и Flux. Абстрактная картина Redux должна быть понятна сейчас. Состояние больше не живет во View (представлении), оно только связано с View (представлением). Что значит связанный? Он связан на двух концах, поскольку является частью однонаправленного потока данных. Один конец отвечает за запуск Action (действия), которое в конечном итоге обновляет состояние, а второй - за получение состояния из Store (хранилища). Следовательно, View (представление) может обновляться в соответствии с изменениями состояния и может вызывать изменения состояния. В этом случае View (представлением) будет React, но Redux можно использовать с любой другой библиотекой или автономно. В конце концов, это всего лишь контейнер управления состоянием.

### Action(s) Действие(я)

Действие в Redux - это JavaScript объект. У него есть тип и дополнительная полезная нагрузка. Тип часто называют **типом действия**. В то время как тип является строковым литералом, полезная нагрузка может быть любой, от строки до объекта.

В начале вашим примером, чтобы познакомиться с Redux, будет приложение Todo. Например, следующее действие в этом приложении можно использовать для добавления нового элемента:

{title="Code Playground",lang="javascript"}
~~~~~~~~
{
  type: 'TODO_ADD',
  todo: { id: '0', name: 'learn redux', completed: false },
}
~~~~~~~~

Выполнение действия называется **диспетчеризация** в Redux. Вы можете отправить действие для изменения состояния в хранилище Redux. Вы отправляете действие только тогда, когда хотите изменить состояние. Отправка действия может быть запущена в вашем слое представления. Это может быть так просто, как нажатие на кнопку HTML. Кроме того, полезная нагрузка в действии Redux не является обязательной. Вы можете определить действия, которые имеют только тип действия. Эта тема будет рассмотрена позже в книге. В конце концов, когда действие отправляется, оно проходит через все редукторы в Redux.

### Редуктор(ы)

Редуктор - это следующая часть в цепочке однонаправленного потока данных. Представление отправляет действие, и объект действия с типом действия и необязательной полезной нагрузкой будет проходить через все редукторы. Что такое редуктор? Редуктор - это чистая функция. Он всегда выдает один и тот же результат, пока входные данные остается неизменными. У него нет побочных эффектов, поэтому это всего лишь операция ввода/вывода. Редуктор имеет два входящих параметра: состояние и действие. Состояние - это всегда весь объект состояния из хранилища Redux. Действие - это отправленное действие с типом и необязательной полезной нагрузкой. Редуктор сокращает - что объясняет наименование - предыдущее состояние и входящее действие до нового состояния.

{title="Code Playground",lang="javascript"}
~~~~~~~~
(prevState, action) => newState
~~~~~~~~

Помимо принципа функционального программирования, а именно того, что редуктор является чистой функцией без побочных эффектов, он также охватывает неизменяемость структуры данных. Он всегда возвращает объект `newState` без изменения входящего объекта `prevState`. Таким образом, следующий редуктор, в котором состояние приложения Todo представляет собой список задач, не является разрешенной функцией редуктора:

{title="Code Playground",lang="javascript"}
~~~~~~~~
function(state, action) {
  state.push(action.todo);
  return state;
}
~~~~~~~~

Это изменило бы предыдущее состояние вместо возврата нового объекта состояния. Следующее допустимо, потому что оно сохраняет предыдущее состояние без изменений:

{title="Code Playground",lang="javascript"}
~~~~~~~~
function reducer(state, action) {
  return state.concat(action.todo);
}
~~~~~~~~

Используя [встроенную в JavaScript функциональность concat](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/concat), состояние и, следовательно, список задач объединяются в другой элемент. Другой элемент - это недавно добавленная задача из действия. Вы можете задаться вопросом, охватывает ли это неизменность сейчас. Да, это так, потому что `concat` всегда возвращает новый массив, не изменяя старый. Структура данных остается неизменной. Вы узнаете больше о том, как сохранить ваши структуры данных неизменяемыми позже.

**А как насчет типа действия?** Пока что только полезная нагрузка используется для создания нового состояния, а тип действия игнорируется. Так что вы можете сделать с типом действия? В основе, когда объект действия прибывает в редукторы, тип действия может быть решающим. Только когда редуктор нуждается в типе действия, он создает новое состояние. В противном случае он просто возвращает предыдущее состояние. В JavaScript инструкция switch может помочь оценить различные типы действий. В противном случае он возвращает предыдущее состояние по умолчанию.

Представьте, что ваше приложение Todo будет иметь второе действие, которое переключает задание либо в завершенное, либо в незавершенное. Единственной информацией, которая необходима в качестве полезной нагрузки, является идентификатор для идентификации задания в состоянии.

{title="Code Playground",lang="javascript"}
~~~~~~~~
{
  type: 'TODO_TOGGLE',
  todo: { id: '0' },
}
~~~~~~~~

Теперь редуктор должен будет выполнить два действия: `TODO_ADD` и `TODO_TOGGLE`. Используя инструкцию switch, вы можете переходить в разные случаи. Если нет подходящего случая, вы возвращаете неизмененное состояние по умолчанию.

{title="Code Playground",lang="javascript"}
~~~~~~~~
function reducer(state, action) {
  switch(action.type) {
    case 'TODO_ADD' : {
      // do something and return new state
    }
    case 'TODO_TOGGLE' : {
      // do something and return new state
    }
    default : return state;
  }
}
~~~~~~~~

В книге уже обсуждались тип действия `TODO_ADD` и его функциональность. Он просто объединяет новый элемент todo с предыдущим списком элементов todo. Но как насчет функциональности `TODO_TOGGLE`?

{title="Code Playground",lang="javascript"}
~~~~~~~~
function reducer(state, action) {
  switch(action.type) {
    case 'TODO_ADD' : {
# leanpub-start-insert
      return state.concat(action.todo);
# leanpub-end-insert
    }
    case 'TODO_TOGGLE' : {
# leanpub-start-insert
      return state.map(todo =>
        todo.id === action.todo.id
          ? Object.assign({}, todo, { completed: !todo.completed })
          : todo
      );
# leanpub-end-insert
    }
    default : return state;
  }
}
~~~~~~~~

В этом примере встроенный метод JavaScript `map` используется для отображения состояния, списка задач, для возврата неизмененного задания или возврата переключенного задания. Переключаемая задача идентифицируется по свойству `id`. [Встроенный метод JavaScript map](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/map) всегда возвращает новый массив. Он не изменяет предыдущее состояние, и, таким образом, состояние задач остается неизменным и может быть возвращено как новое состояние.

Но разве переключенный todo не мутировал? Нет, потому что `Object.assign()` возвращает новый объект без изменения старого объекта. `Object.assign()` объединяет все данные объекты от первого до последнего друг в друга. Если первый объект имеет то же свойство, что и последний объект, будет использоваться свойство последнего объекта. Таким образом, свойство `completed` обновленного элемента todo будет отрицательным состоянием старого элемента todo.

Обратите внимание, что эти функции - действия и редуктор чистый JavaScript. Пока не задействована ни одна функция из библиотеки Redux. Нет скрытой библиотечной магии. Это простой JavaScript с принципами функционального программирования.

Стоит знать одна вещь о текущем редукторе: он увеличился в размерах, что делает его менее поддерживаемым. Для поддержания чистоты редукторов часто различные ветви инструкции switch извлекаются как чистые функции:

{title="Code Playground",lang="javascript"}
~~~~~~~~
function reducer(state, action) {
  switch(action.type) {
    case 'TODO_ADD' : {
# leanpub-start-insert
      return applyAddTodo(state, action);
# leanpub-end-insert
    }
    case 'TODO_TOGGLE' : {
# leanpub-start-insert
      return applyToggleTodo(state, action);
# leanpub-end-insert
    }
    default : return state;
  }
}

# leanpub-start-insert
function applyAddTodo(state, action) {
  return state.concat(action.todo);
}

function applyToggleTodo(state, action) {
  return state.map(todo =>
    todo.id === action.todo.id
      ? Object.assign({}, todo, { completed: !todo.completed })
      : todo
  );
}
# leanpub-end-insert
~~~~~~~~

В конце концов, приложение Todo теперь имеет два действия и один редуктор. Остается последняя часть в структуре Redux: Хранилище (Store).

### Хранилище (Store)

До сих пор в приложении Todo был способ инициировать обновления состояния (действия) и способ привести предыдущее состояние и действие к новому состоянию (редуктор). Но никто не склеивал эти части вместе.

* Кто делегирует действия редуктору?
* Кто запускает действия?
* И, наконец, где я могу получить обновленное состояние, чтобы связать его с моим видом?

Это хранилище Redux. Хранилище содержит один глобальный объект состояния. Здесь нет нескольких хранилищ и нет нескольких состояний. Хранилище есть в единственном экземпляре в вашем приложении. Кроме того, это первая библиотечная зависимость, с которой вы сталкиваетесь при использовании Redux. Поэтому используйте оператор import, чтобы получить функциональность для создания объекта `store` из библиотеки Redux.

{title="Code Playground",lang="javascript"}
~~~~~~~~
import { createStore } from 'redux';
~~~~~~~~

Теперь вы можете использовать его для создания единственного экземпляра хранилища. Функция `createStore` принимает один обязательный аргумент: редуктор. Вы уже определили редуктор в главе «Редуктор», который добавляет и дополняет элементы задач.

{title="Code Playground",lang="javascript"}
~~~~~~~~
const store = createStore(reducer);
~~~~~~~~

Кроме того, `createStore` принимает второй необязательный аргумент: начальное состояние. В случае приложения Todo редуктор работал со списком задач в качестве состояния. Список элементов задач должен быть инициализирован как пустой массив или предварительно заполненный массив с задачами. Если он не был инициализирован, редуктор потерпит неудачу, потому что он будет работать с аргументом `undefined`.

{title="Code Playground",lang="javascript"}
~~~~~~~~
const store = createStore(reducer, []);
~~~~~~~~

В другой главе книга продемонстрирует еще один способ инициализации состояния в Redux. Затем вы будете использовать редуктор вместо хранилища, чтобы инициализировать состояние на более детальном уровне.

Теперь у вас есть экземпляр хранилища, который знает о редукторе. Настройка Redux завершена. Однако важная часть отсутствует: вы хотите взаимодействовать с хранилищем. Вы хотите отправлять действия по изменению состояния, получать состояние из хранилища и прослушивать обновления состояния в хранилище.

Итак, первое, как отправить действие?

{title="Code Playground",lang="javascript"}
~~~~~~~~
store.dispatch({
  type: 'TODO_ADD',
  todo: { id: '0', name: 'learn redux', completed: false },
});
~~~~~~~~

Второе: как получить глобальное состояние из хранилища?

{title="Code Playground",lang="javascript"}
~~~~~~~~
store.getState();
~~~~~~~~

И третье, как подписаться (и отписаться) на обновления хранилища, чтобы отслеживать (и не нет) обновления?

{title="Code Playground",lang="javascript"}
~~~~~~~~
const unsubscribe = store.subscribe(() => {
  console.log(store.getState());
});

unsubscribe();
~~~~~~~~

Вот и все. Хранилище Redux имеет только небольшой API для доступа к состоянию, обновления и прослушивания обновлений. Это одно из существенных ограничений, которые сделали Redux таким успешным.

### Практика: Redux

Теперь вы знаете обо всех основах Redux. Представление отправляет действие в хранилище, оно пропускает все редукторы и уменьшается редукторами, которые заботятся о нем. Хранилище сохраняет новый объект состояния. Наконец, слушатель обновляет представление новым состоянием.

{title="Concept Playground",lang="text"}
~~~~~~~~
Представление (View) -> Действие (Action) -> Редутор(ы) (Reducer(s)) -> Хранилище (Store) -> Представление (View)
~~~~~~~~

Давайте применим эти знания. Вы можете использовать свой собственный проект, в котором включены JavaScript, функции JavaScript ES6 и Redux, или открыть этот JS Bin: [Redux Playground](https://jsbin.com/zukogaj/2/edit?html,js,console). Теперь вы можете применить свои знания о действиях, редукторах и магазине из последней главы. Во-первых, вы можете определить свой редуктор, который занимается добавлением и переключением элементов todo:

{title="Code Playground",lang="javascript"}
~~~~~~~~
function reducer(state, action) {
  switch(action.type) {
    case 'TODO_ADD' : {
      return applyAddTodo(state, action);
    }
    case 'TODO_TOGGLE' : {
      return applyToggleTodo(state, action);
    }
    default : return state;
  }
}

function applyAddTodo(state, action) {
  return state.concat(action.todo);
}

function applyToggleTodo(state, action) {
  return state.map(todo =>
    todo.id === action.todo.id
      ? Object.assign({}, todo, { completed: !todo.completed })
      : todo
  );
}
~~~~~~~~

Во-вторых, вы можете инициализировать хранилище Redux, которое использует редуктор и исходное состояние. В JS Bin у вас есть Redux, доступный как глобальная переменная.

{title="Code Playground",lang="javascript"}
~~~~~~~~
const store = Redux.createStore(reducer, []);
~~~~~~~~

Если вы находитесь в своем собственном проекте, вы можете импортировать `createStore` из библиотеки Redux:

{title="Code Playground",lang="javascript"}
~~~~~~~~
import { createStore } from 'redux';

const store = createStore(reducer, []);
~~~~~~~~

В-третьих, вы можете отправить свое первое действие в хранилище.

{title="Code Playground",lang="javascript"}
~~~~~~~~
store.dispatch({
  type: 'TODO_ADD',
  todo: { id: '0', name: 'learn redux', completed: false },
});
~~~~~~~~

Вот и все. Вы настроили все части Redux и взаимодействовали с ним с помощью действия. Вы можете извлечь состояние, получив его из хранилища.

{title="Code Playground",lang="javascript"}
~~~~~~~~
console.log(store.getState());
~~~~~~~~

Но вместо того, чтобы выводить его вручную, вы можете подписать функцию обратного вызова в хранилище, чтобы вывести последнее состояние после его изменения. Не забудьте подписаться на хранилище, прежде чем отправлять свои действия, чтобы получить вывод.

{title="Code Playground",lang="javascript"}
~~~~~~~~
const unsubscribe = store.subscribe(() => {
  console.log(store.getState());
});
~~~~~~~~

Теперь, когда вы отправляете действие, после того, как состояние обновлено, подписка на хранилище должна стать активной после вывода вашего текущего состояния. Не забудьте отписаться, чтобы избежать утечек памяти.

{title="Code Playground",lang="javascript"}
~~~~~~~~
unsubscribe();
~~~~~~~~

Готовое приложение можно найти [в этом примере JS Bin](https://jsbin.com/kopohur/28/edit?html,js,console). Прежде чем продолжить чтение, вы должны поэкспериментировать с проектом. То, что вы видите в проекте - это чистый JavaScript с хранилищем Redux. Вы можете придумывать больше действий и разбираться с ними в своем редукторе. Приложение должно вам понимание того, что Redux является только контейнером состояний. Состояние может быть изменено с помощью действий. Редуктор позаботится о своем действии. Он использует действие и старое состояние для создания нового состояния в хранилище Redux.

Позже вы узнаете, как подключить хранилище Redux к вашему слою представления React. Но перед этим давайте углубимся в действия и редукторы.