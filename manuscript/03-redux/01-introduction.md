# Redux

Redux - это одна из библиотек, которая помогает вам реализовать сложное управление состоянием в ваших приложениях. Это выходит за рамки локального состояния (например, локальное состояние React). Это одно из решений, которое вы можете применить в масштабирующем приложении, чтобы укротить состояние. Приложение React идеально подходит для Redux, но другие библиотеки и фреймворки также высоко оценили его концепции.

**Почему Redux так популярен в сообществе JavaScript?** Чтобы ответить на этот вопрос, нужно немного углубиться в прошлое JavaScript приложений. В начале была одна библиотека, которая управляла ими всеми: jQuery. В основном она использовался для манипулирования DOM, чтобы удивлять анимацией и реализовывать многократно используемые виджеты. Это была библиотека номер один в JavaScript. Не было никакого способа обойтись без нее. Тем не менее, использование jQuery резко возросло, и приложения выросли в размерах. Но не по размеру HTML и CSS, это был скорее размер кода в JavaScript. В конце концов, код в этих приложениях стал беспорядочным, потому что не было надлежащей архитектуры или структуры вокруг него. Печально известный код спагетти стал проблемой в JavaScript приложениях.

Пришло время для появления новых решений, выходящих за рамки jQuery. Эти библиотеки, большинство из которых являются фреймворками, предоставят инструменты для правильной архитектуры в интерфейсных приложениях. Кроме того, они привнесли взвешенные подходы к решению проблем. Эти решения позволили разработчикам внедрить одностраничные приложения (SPA).

Одностраничные приложения стали популярны, когда были выпущены первое поколение фреймворков и библиотек, в том числе Angular 1, Ember и Backbone. Внезапно у разработчиков появились фреймворки для создания масштабируемых веб-приложений. Однако, поскольку история повторяет сама себя, с каждой новой технологией будут возникать новые проблемы. В СПА каждое решение имело разный подход к управлению состоянием. Например, Angular 1 использовал печально известную двустороннюю привязку данных. Он также использовал двунаправленный поток данных. Только после того, как приложения выросли в размерах, проблема управления состоянием стала широко известна.

За это время Facebook выпустил React. Это было одно из решений SPA второго поколения. По сравнению с первым поколением, это была библиотека, которая использовала только слой представления.С ним в комплекте шло собственным решением для управления состоянием: локального управления состоянием React.

В React стал популярным принцип однонаправленного потока данных. Управление состоянием должно быть более предсказуемым, чтобы подерживать это. Тем не менее, управления локальным состоянием не было достаточно в какой-то момент. Приложения React хорошо масштабируются, но сталкиваются с теми же проблемами предсказуемого и поддерживаемого управления состоянием при создании более крупных приложений. Несмотря на то, что проблемы не были такими разрушительными, как в приложениях с двунаправленным потоком данных, после того, как приложение стало больше, возникла проблема. Это было время, когда Facebook представил архитектуру Flux.

Архитектура Flux - это шаблон для управления состоянием в масштабируемых приложениях. Официальный сайт сообщает, что *«[...]однонаправленный поток данных занимает центральное место в шаблоне Flux [...]»*. Данные передаются только в одном направлении. Помимо однонаправленного потока данных, архитектура Flux включает в себя четыре основных компонента: Action (действие), Dispatcher (диспетчер), Store (хранилище) и View (представление). View (представление) - это, в основном, дерево компонентов в современном приложении. Например, React - это такой View (представление). Пользователь может взаимодействовать с представлением, чтобы вызвать Action (действие). Action (действие) будет инкапсулировать всю необходимую информацию для обновления состояния в Store (хранилище(ях)). Dispatcher (диспетчер) на пути делегирует Action (действие) в Store (хранилище(ях)). Новое состояние будет передаваться из Store (хранилища) в View (представление) для их обновления. Последняя часть замыкает цикл однонаправленного потока данных.

Поток данных идет в одном направлении. View (представление) может инициировать Action (действие), которое проходит через Dispatcher (диспетчер) и Store (хранилище), и в конечном итоге изменяет View (представление), когда состояние в хранилище изменяется. Однонаправленный поток данных заключен в этом цикле. С другой стороны, представление может вызвать другое Action (действие). С тех пор как Facebook представил архитектуру Flux, View (представление) было связано с React и его компонентами.

Вы можете [узнать больше об архитектуре Flux на официальном сайте](https://facebook.github.io/flux/). Там вы также найдете [видео его представлении на конференции](https://youtu.be/nYkdrAPrdcw?list=PLb0IAmt7-GS188xDYE-u1ShQmFFGbrk0v). Если вас интересует происхождение Redux, я настоятельно рекомендую прочитать и посмотреть материал. В конце концов, Redux стал наследником архитектуры Flux. Несмотря на то, что вокруг архитектуры Flux было множество решений, Redux удалось их превзойти. Но почему это удалось?

[Дан Абрамов](https://twitter.com/dan_abramov) и [Эндрю Кларк](https://twitter.com/acdlite) являются создателями Redux. Он был [представлен Дэном Абрамовым на React Europe](https://www.youtube.com/watch?v=xsSnOQynTHs) в 2015 году. Тем не менее, речь Дэна не представляет Redux как таковой. Вместо этого речь знакомит проблемой, с которой столкнулся Дан Абрамов, что привело к внедрению Redux. Я не хочу исклажать содержание разговора, поэтому я призываю вас посмотреть видео самостоятельно. Если вы заинтересованы в изучении Redux, вам следует погрузиться в проблему, которая была решена им.

Год спустя, снова на React Europe, Дан Абрамов размышлял о путешествии Redux и его успехах. Он упомянул несколько вещей, которые сделали Redux успешной, по его мнению. Во-первых, Redux был разработан для решения проблемы. Проблема была объяснена Дэном Абрамовым годом ранее, когда он представил Redux. Это была не просто еще одна библиотека. Это была библиотека, которая решала проблему. Time Traveling (путешествие во времени) и Hot Reloading (горячая перезагрузка) были стресс-тестом для Redux. Во-вторых, ограничения Redux были еще одним ключевым фактором его успеха. Redux удалось отгородить проблему с помощью простого API и продуманного способа решения проблемы управления состоянием. Вы также можете [посмотреть этот доклад](https://www.youtube.com/watch?v=uvAXVMwHJXU). Я очень рекомендую это. Либо вы смотрите это прямо сейчас, либо после следующей главы, которая знакомит вас с основами Redux.
