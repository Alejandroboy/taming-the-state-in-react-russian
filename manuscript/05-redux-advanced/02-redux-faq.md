# (React в) Redux FAQ

Я намереваюсь расширять этот раздел органично, чтобы отвечать на часто задаваемые вопросы, насколько насколько хватит моих знаний. Это вопросы, которые часто возникают при обсуждении Redux отдельно или в качестве дополнения к React.

## Redux vs. Локальное состояние

Представляя Redux в приложении React, люди не уверены, как обрабатывать локальное состояние с помощью `this.state` и `this.setState()`. Должны ли они полностью заменить локальное состояние на Redux или оставить смесь обоих? Большая часть сообщества будет утверждать, что последнее, и я согласен с этим. Локальное состояние не устареет при использовании сложной библиотеки управления состоянием, такой как Redux. Вы бы все равно использовали это.

Представьте, что ваше приложение растет в виде строк кода и количества разработчиков, работающих над этим приложением. Ваше глобальное состояние в Redux тоже обязательно будет расти. Тем не менее, вы хотите, чтобы глобальное состояние содержало смысл и использовалось повторно несколькими сторонами (разработчиками, компонентами) в вашем приложении. Вот почему не все должно в конечном итоге попадать в глобальном состоянии. В растущем приложении вы всегда должны пересматривать свое глобальное состояние и следить за тем, чтобы оно было продуманно и не загромождено.

Беспорядок происходит, когда слишком много состояния заканчивается в глобальном состоянии, которое используется только одной стороной (один компонент, одна часть дерева компонентов). Вы должны дважды подумать об этом виде состояния и оценить, имеет ли смысл вводить местное состояние. Всегда спрашивайте себя: кому интересно это состояние? Сбалансированное сочетание локального и сложного состояния сделает ваше приложение поддерживаемым и предсказуемым в долгосрочной перспективе.

Границы между локальным состоянием и сложным состоянием будут размыты при использовании библиотеки управления состояниями, такой как MobX, в качестве альтернативы Redux. Вы узнаете о MobX позже в этой книге. Но и там вы можете заранее тщательно продумать свое состояние в своем приложении.

В общем, использование состояния Redux должно быть сведено к минимуму. Хорошее эмпирическое правило - держать состояние близко к вашему компоненту с локальным состоянием, но позже оцените, заинтересована ли другая сторона в этом состоянии. Если другая сторона управляет эквивалентной структурой  состояния в своем локальном государстве, вы можете использовать переиспользуемый компонент высокого порядка, чтобы управляеть состоянием. Если состояние является общим, вы можете попытаться поднять свое состояние вверх или вниз по иерархии компонентов. Однако, если снятие состояния не решает проблему для вас, потому что состояние совместно используется приложением, вам следует рассмотреть возможность использования Redux для него. В конце концов, после пересмотра всех ваших возможностей при использовании только локального состояния React, вам может не понадобиться Redux в вашем приложении.

## Состояние представление vs. Состояния сущности

В начале книги я провел различие между состоянием представления и состоянием сущности. Представьте, что у вас есть страница, которая отображает как список элементов, так и показывает модальные опции для каждого элемента, чтобы удалить или изменить элемент. В то время как первый будет состоянием сущности, второй будет состоянием просмотра. Состояние объекта, список элементов, чаще всего поступает из бэкенда приложения. Но состояние представления запускается пользователем только во фронтенде. Есть ли образец того, где хранить, какое состояние?

Состояние сущности часто приходит от бэкэнда. Получается асинхронно. В приложениях вы хотите избежать запроса сущностей более одного раза. Хорошей практикой будет выборка сущностей один раз, а не снова, когда они уже есть. Таким образом, они должны быть сохранены где-нибудь, где несколько сторон знают, что эти сущности уже запрошены. Глобальное состояние - идеальное место для их хранения.

Состояние представления изменяется только фронтендом. Часто оно не распределяется на все приложении, потому что, например, только модальное окно знает, открыто оно или закрыто. Так как сосотояние не обязанно быть распределенным, вы можете использовать локальное состояние и избежать беспорядка в глобальном состоянии.

Представьте, что у вас есть компонент с вкладками. Каждая вкладка дает вам возможность изменить представление отображаемых элементов. Например, пользователь может выбрать сетку или список для отображения элементов. Хранить это состояние в местном состоянии совершенно нормально. Кроме того, вы можете предоставить своему пользователю улучшенный пользовательский интерфейс. Вы также можете сохранить выбранную вкладку в локальном хранилище вашего браузера, и когда пользователь вернется на страницу, вы наполните локальное состояние из локального хранилища. Пользователь всегда найдет предпочитаемую вкладку как выбранную.

## Случайное vs. планированное Состояние

Можете ли вы спланировать состояние? Я бы сказал, что вы можете. Вы можете спланировать, какая часть состояния переходит в глобальное состояние, а какая часть в локальное состояние. Например, вы знаете о состоянии представления и сущности. Кроме того, вы можете поместить часть своего состояния в локальное хранилище, чтобы улучшить взаимодействие с пользователем. Однако в развивающемся приложении состояние растет, а структура меняется. Что вы можете с этим поделать? Моя рекомендация - всегда пересматривать ваши устройство и структуру состояния. Всегда есть место для улучшений. Вы должны провести рефакторинг на ранней стадии, чтобы поддерживать его в рабочем состоянии и прогнозировать в долгосрочной перспективе.
