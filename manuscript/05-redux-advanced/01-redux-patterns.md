# Шаблоны, методики и лучшие практики Redux

Существует несколько шаблонов и рекомендаций, которые вы можете применить в приложении Redux. Я пройдусь через несколько из них, чтобы указать вам правильное направление. Однако развивающиеся модели и лучшие практики вокруг экосистемы постоянно меняются. Вам захочется прочитать больше об этих темах самостоятельно.

## Использование JavaScript ES6

Пока что вы написали свой код Redux в основном на JavaScript ES5. Redux вдохновлен парадигмой функционального программирования и использует множество ее концепций: неизменяемые структуры данных и чистые функции. При использовании Redux в масштабирующем приложении вы часто используете чистые функции, которые решают только одну проблему. Например, создатель действия возвращает только объект действия, редуктор возвращает только новое состояние, а селектор возвращает только извлеченные свойства. Вы примете эту ментальную модель и будете использовать ее в коде, независимом от Redux. Вы будете чаще видеть себя использующими функции, которые решают только одну проблему, используя функции высшего порядка для возврата функций и составления функций друг в друга. Вы будете двигаться в направлении функционального стиля программирования с Redux.

JavaScript ES6 и более поздние версии прекрасно дополняют функциональный стиль программирования в JavaScript. Вам нужно только взглянуть на следующий пример, чтобы понять, как много более кратких функций высшего порядка можно написать с помощью стрелочных функций JavaScript ES6.

{title="Code Playground",lang="javascript"}
~~~~~~~~
// JavaScript ES5
function higherOrderFunction(foo) {
  return function (bar) {
      ...
  };
}

// JavaScript ES6
const higherOrderFunction = (foo) => (bar) => { ... };
~~~~~~~~

Это функция высшего порядка, которая гораздо более читаема в JavaScript ES6. Вы будете чаще использовать функции высшего порядка при программировании в функциональном стиле. Может случиться, что вы используете не просто функцию высшего порядка, но функцию высшего порядка, которая возвращает функцию высшего порядка, которая возвращает функцию. Снова становится легче читать при использовании JavaScript ES6.

{title="Code Playground",lang="javascript"}
~~~~~~~~
// JavaScript ES5
function higherOrderFunction(foo) {
  return function (bar) {
      return function (qwe) {
        ...
      }
  };
}

// JavaScript ES6
const higherOrderFunction = (foo) => (bar) => (qwe) => { ... };
~~~~~~~~

I encourage you to apply these in your Redux code. It would turn out the following way:
Я призываю вас применить их в своем коде Redux. Может получиться так:

{title="Code Playground",lang="javascript"}
~~~~~~~~
// action creator
const doAddTodo = (id, name) => ({
  type: ADD_TODO,
  todo: { id, name },
});

// selector
const getTodos = (state) => state.todos;

// action creators using Redux Thunk
const showNotificationWithDelay = (text) => (dispatch) => {
  dispatch(doShowNotification(text));
  setTimeout(() => dispatch(doHideNotification()), 1000);
}
~~~~~~~~

Сообщество JavaScript сделало большой шаг в сторону функционального программирования с ростом популярности React и Redux. Функциональное программирование позволяет вам писать более предсказуемый код, используя чистые функции, повышая осведомленность о побочных эффектах и сохраняя неизменность структур данных. JavaScript ES6 и более поздние версии делают его более удобным для чтения и написания в функциональном стиле.

## Соглашения об именовании

В Redux у вас есть несколько различных типов функций. У вас есть создатели действий, селекторы и редукторы. Это всегда хорошо, чтобы назвать их в соответствии с их типом. Другим разработчикам будет легче определить тип функции. Просто следуя соглашению об именах для ваших функций, вы можете дать себе и другим ценную информацию о самой функции.

Лично я соблюдаю это соглашение об именах с функциями Redux. Оно использует префиксы для каждого типа функции:

* оздатели действий: **do**Something
* редукторы: **apply**Something
* селекторы: **get**Something
* саги: **watch**Something, **handle**Something

В предыдущих главах пример кода всегда использовал это соглашение об именах. Кроме того, это проясняет вещи при использовании функций высшего порядка. Помните функцию `mapDispatchToProps()` при подключении Redux к React?

{title="Code Playground",lang="javascript"}
~~~~~~~~
const mapStateToProps = (state) => ({
  todos: getTodos(state),
});

const mapDispatchToProps = (dispatch) => ({
   onToggleTodo: (id) => dispatch(doToggleTodo(id)),
});
~~~~~~~~

Сами функции становятся более краткими благодаря использованию стрелочных функций JavaScript ES6. Но есть и другая подсказка, которая делает правильное именование настолько мощным. Только с точки зрения именования вы можете видеть, что функции `mapStateToProps()` и `mapDispatchToProps()` преобразуют возвращаемые свойства из мира Redux в мир React. Подключенный компонент больше не знает о селекторах или создателях действий. Как видите, это уже выражено в преобразованных реквизитах и функциях. Они называются `todos` и `onToggleTodo`. Там нет остатков от мира Redux, с технической точки зрения, но и с точки зрения чистого именования. Это мощно, потому что ваши базовые компоненты не зависят от Redux.

Пока что глава посвящена только именам функций в мире Redux. Но есть и другая часть в Redux, которую можно правильно назвать: типы действий. Рассмотрим следующие имена типов действий:

{title="Code Playground",lang="javascript"}
~~~~~~~~
const ADD_TODO = 'ADD_TODO';
const TODO_ADD = 'TODO_ADD';
~~~~~~~~

Большинство культур читают слева направо. Это выражается и в программировании. Так какой тип именования действий имеет больше смысла? Это глагол или предмет? Вы можете принять решение по своему усмотрению, но составьте четкое представление о согласованном соглашении об именах для ваших типов действий. Лично мне легче сканировать, когда у меня есть тема, в данном случае область. Когда я использую Redux Logger в масштабирующем приложении, в которое можно отправить сразу несколько действий, мне легче сканировать по предмету, чем по глаголу. Вы даже можете пойти еще дальше и применить тему в качестве префикса домена для ваших типов действий:

{title="Code Playground",lang="javascript"}
~~~~~~~~
const todo/ADD = 'todo/ADD';
~~~~~~~~

These are only opinionated naming conventions for these types of functions and constants (action types) in Redux. You can come up with your own. But do yourself and your fellow developers a favor and reach an agreement first and then apply them consistently through your code base.
Это только условные соглашения об именах для этих типов функций и констант (типов действий) в Redux. Вы можете придумать свое. Но сделайте себе и своим коллегам-разработчикам услугу и сначала достигните соглашения, а затем последовательно применяйте их в своей кодовой базе.

## Связь между действиями и редукторами

Действия и редукторы не являются строго связанными. Их объединяет только тип действия. Отправленное действие, например, с типом действия `TODO_ADD`, может быть зафиксировано в нескольких редукторах, которые используют `TODO_ADD`. Вы делали это раньше в `todoReducer` и `messagesReducer`. Это важный факт при реализации более широкой архитектуры управления состоянием в вашем приложении.

Если исходить из опыта объектно-ориентированного программирования, вы можете злоупотреблять действиями/редукторами как сеттерами, а селекторы - как геттерами. Вы будете сочетать действия и редукторы в соотношении 1:1. Я назову это **шаблон команды** в Redux. Это может быть полезно в некоторых сценариях, как я укажу позже, но в целом это не философия Redux.

Redux можно рассматривать как шину событий вашего приложения. Вы можете отправлять события (действия) с полезной нагрузкой и идентификатором (типом действия) в шину, и они будут передаваться потенциальному потребителю (редукторам). Только часть этих потребителей заинтересована в событии. Это то, что я называю **шаблоном событий**, который использует Redux.

Вы можете сказать, что чем выше вы размещаете свои действия в спектре абстракции, тем больше редукторов в нем заинтересованы. Действие становится событием. Чем ниже вы размещаете свои действия в спектре абстракции, тем меньше редукторов в нем заинтересованы. В конце концов, чаще всего его может потреблять только один редуктор, когда он находится на более низком месте спектра абстракции. Действие становится командой. Это конкретное действие, а не абстрактное действие. Однако важно отметить, что вы должны соблюдать баланс между абстракцией и конкретностью. Слишком абстрактные действия могут привести к путанице, когда слишком много редукторов используют его. Слишком конкретные действия могут быть использованы только одним редуктором все время. Большинство разработчиков сталкиваются с последним сценарием. В Redux, очевидно, в зависимости от вашего приложения, это должен быть здоровый баланс обоих.

В этой книге вы большую часть времени встречали связь 1:1 между действием и редуктором (за исключением действия `TODO_ADD`). Давайте выполним действие, которое завершает элемент todo в качестве демонстрации:

{title="Code Playground",lang="javascript"}
~~~~~~~~
function doCompleteTodo(id) {
  return {
    type: TODO_COMPLETE,
    todo: { id },
  };
}

function todosReducer(state = [], action) {
  switch(action.type) {
    case TODO_COMPLETE : {
      return applyCompleteTodo(state, action);
    }
    default : return state;
  }
}
~~~~~~~~

Теперь представьте, что должно быть измерение прогресса пользователя приложения Todo. Ход выполнения всегда начинается с нуля, когда пользователь открывает приложение. Когда задача завершена, прогресс должен увеличиться на единицу. Потенциально простым решением может быть подсчет всех завершенных задач. Однако, поскольку уже могут быть завершенные элементы задач, и вы хотите измерить завершенные элементы задач в этом сеансе, этого решения будет недостаточно. Решением может быть второй редуктор, который считает завершенные задачи в этом сеансе.

{title="Code Playground",lang="javascript"}
~~~~~~~~
function progressReducer(state = 0, action) {
  switch(action.type) {
    case TODO_COMPLETE : {
      return state++;
    }
    default : return state;
  }
}
~~~~~~~~

Счетчик будет увеличиваться при завершении задачи. Теперь вы можете легко измерить прогресс ваших пользователей, когда они завершают задачи. Внезапно между действием и редуктором возникает соотношение 1:2. Действие, которое используется для завершения элемента todo, выполняется двумя редукторами. Никто не заставляет вас объединять действия и редукторы в отношении 1:1, но всегда имеет смысл проявлять творческий подход в этом отношении. Что может случится в противном случае? Что касается проблемы измерения прогресса, вам, возможно, придется придумать второй тип действия и связать его с предыдущим редуктором:

{title="Code Playground",lang="javascript"}
~~~~~~~~
# leanpub-start-insert
function doTrackProgress() {
  return {
    type: PROGRESS_TRACK,
  };
}
# leanpub-end-insert

function progressReducer(state = 0, action) {
  switch(action.type) {
# leanpub-start-insert
    case PROGRESS_TRACK : {
# leanpub-end-insert
      return state++;
    }
    default : return state;
  }
}
~~~~~~~~

Действие будет отправлено параллельно с действием `COMPLETE_TODO`.

{title="Code Playground",lang="javascript"}
~~~~~~~~
dispatch(doCompleteTodo('0'));
dispatch(doTrackProgress());
~~~~~~~~

Но это упустило бы смысл Redux. Вы хотели бы придумать эти общие черты, чтобы сделать ваши действия более абстрактными и использовались несколькими редукторами. Мое эмпирическое правило: подходите к своим действиям как к конкретным действиям с отношением 1:1 с их редукторам, но всегда оставайтесь открытыми и используйте их как более абстрактные действия в других редукторах.

## Организация папок

Со временем ваше приложение Redux растет, и вы не можете управлять всем - редукторами, создателями действий, селекторами, хранилищем и представлением - в одном файле. Вам придется разделить файлы. К счастью, JavaScript ES6 предосталяет [import](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/import) и [export](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/export) операторы для распределения функций в файлах. Если вы не знакомы с ними, вы должны прочитать о них.

В этой главе я хочу показать вам два подхода к организации вашей папки и файлов в приложении Redux. Первый подход, **техническая организация папок**, используется в небольших приложениях. Когда ваше приложение масштабируется и над проектом работает более одной команды, вы можете рассмотреть **функциональную организацию папок**. Кроме того, в этой главе вы узнаете о передовых практиках для структуры файлов и папок.

### Техническая организация папок

Техническое разделение интересов используется в небольших приложениях. В принципе, на мой взгляд, есть два требования для использования этого подхода:

* приложением управляет только один человек или одна команда, поэтому имеет меньший конфликтный потенциал при работе с одной и той же кодовой базой
* приложение маленькое с точки зрения кода и *может* управляться одним человеком или одной командой

В заключение, все зависит от размера команды и размера базы кода. Теперь, как разделить файлы? Они разделяются по своим техническим аспектам:

{title="Folder Organization",lang="text"}
~~~~~~~~
-app
--reducers
--actions creators
--selectors
--store
--constants
--components
~~~~~~~~

Редукторы, создатели действий, селекторы и хранилище должны быть чистыми. В этих папках у вас есть все аспекты Redux. В папке компонентов у вас есть слой представления. При использовании React, это будет место, где вы найдете ваши компоненты React. В папке констант вы можете иметь любые константы, а также типы действий Redux. Их можно импортировать в создателей действия и редукторы. Детализированная организация папок/файлов, разделенная по техническим аспектам, может выглядеть следующим образом:

{title="Folder Organization",lang="text"}
~~~~~~~~
-app
--reducers
---todoReducer.js
---filterReducer.js
---notificationReducer.js
--actions creators
---filters.js
---todos.js
---notifications.js
--selectors
---filters.js
---todos.js
---notifications.js
--store
---store.js
--constants
---actionTypes.js
--components
---TodoList.js
---TodoItem.js
---Filter.js
---Notifications.js
~~~~~~~~

Каковы преимущества и недостатки этого подхода? Наиболее важным преимуществом является то, что редукторы и создатели действий не связаны. Они свободно расположены в своих папках. Он охватывает идею Redux для захвата любых действий в любом редукторе. Редукторы и создатели действий не находятся в соотношении 1:1. Кроме того, все функциональные возможности Redux доступны с верхнего уровня. Ни одна из этих функций не скрыта на более низком уровне и, следовательно, более доступна. Этот подход охватывает шаблон событий, который был упомянут ранее. Недостаток этого подхода, а следовательно, и двух требований, заключается в том, что он плохо масштабируется. Каждая техническая папка будет расти бесконечно. Нет ограничений, кроме разделения по типу. Это может стать беспорядком после того, как вы создадите несколько редукторов, создателей действий и селекторов.

### Функциональную организацию папок

Второй подход, разделение по функции, чаще всего используется в более крупных приложениях. У вас больше гибкости в группировании функций, потому что вы всегда можете разделить большие функции на более мелкие и таким образом сохранить папки легкими.

{title="Folder Organization",lang="text"}
~~~~~~~~
-app
--todo
--filter
--notification
--store
~~~~~~~~

Детализированная организация папок/файлов может выглядеть следующим образом:

{title="Folder Organization",lang="text"}
~~~~~~~~
-app
--todo
---TodoList.js
---TodoItem.js
---reducer.js
---actionCreators.js
---selectors.js
--filter
---Filter.js
---reducer.js
---actionCreators.js
---selectors.js
--notification
---Notifications.js
---reducer.js
---actionCreators.js
---selectors.js
--store
---store.js
~~~~~~~~

Этот подход, разделяющий по функциям, является более гибким, чем предыдущий подход. Это дает вам больше свободы для размещения ваших папок и файлов по функциям. При использовании этого подхода есть больше способов сделать это. Вам не обязательно следовать примеру выше.

Каковы преимущества и недостатки этого подхода? Он имеет те же преимущества и недостатки, что и техническая организация папок, но противоположные. Вместо того, чтобы создавать создателей и редукторов действий на верхнем уровне, они скрыты в папке функций. В масштабируемом приложении с несколькими командами другие команды, скорее всего, не будут повторно использовать ваши создатели действий и редукторы, а будут реализовывать свои собственные. Другим недостатком является то, что он группирует создателей действий и редукторов в соотношении 1:1, что противоречит всеобъемлющей идее Redux. Вы включаете шаблон команды вместо шаблона события. Преимущество с другой стороны, и именно поэтому большинство команд в масштабирующем приложении используют этот подход, заключается в том, что оно хорошо развивается. Команды могут работать с отдельными папками и не сталкиваться с конфликтами. Тем не менее они могут следовать всеобъемлющему потоку управления состоянием при использовании библиотеки промежуточного ПО, такой как redux-logger.

Несмотря на то, что функциональная организация папок несет много ловушек, поскольку она использует шаблон команды, упомянутый ранее, она часто используется при масштабировании приложений с несколькими группами разработчиков. Поэтому я могу дать один важный совет этому подходу: постарайтесь сделать свои создатели действий, редукторы и селекторы доступными для всех, чтобы их можно было повторно использовать. Это может прописать в документации, передавать из уст в уста или выбрав другой вариант организации папок/файлов.

### Ducks

В Redux существует еще одна концепция, называемая ducks. Это относится к организации создателей действий, типов действий и редукторов как кортежей. Концепция ducks объединяет эти кортежи в автономные модули. Часто эти модули заканчиваются только одним файлом. В официальном шаблоне ducks есть несколько рекомендаций, которые вы можете прочитать в [GitHub repository](https://github.com/erikras/ducks-modular-redux). Однако вам не нужно применять все это. Например, в приложении Todo файл ducks для раздела фильтра может выглядеть следующим образом:

{title="Code Playground",lang="javascript"}
~~~~~~~~
const FILTER_SET = 'FILTER_SET';

function filterReducer(state = 'SHOW_ALL', action) {
  switch(action.type) {
    case FILTER_SET : {
      return applySetFilter(state, action);
    }
    default : return state;
  }
}

function applySetFilter(state, action) {
  return action.filter;
}

function doSetFilter(filter) {
  return {
    type: FILTER_SET,
    filter,
  };
}

export default filterReducer;

export {
  doSetFilter,
};
~~~~~~~~

Та же файловая структура будет применяться для функции уведомления и самой функции todo. Недостатки концепции ducks аналогичны подходу папок объектов. Вы объединяете действия и редукторы, поэтому никто не будет охватывать действия в нескольких редукторах. Пока действие и редуктор связаны, концепция уток имеет смысл. В противном случае, это не должно применяться слишком часто. Вместо этого вы должны принять идею Redux, чтобы ваши редукторы и создатели действий были доступны на верхнем уровне.

## Тестирование

Книга не будет глубоко погружаться в тему тестирования, но стоит упоминать о ней. Тестирование вашего кода в программировании необходимо и должно рассматриваться как обязательное. Вы хотите поддерживать высокое качество своего кода и гарантировать, что все работает. Однако тестирование вашего кода часто может быть утомительным. Вы должны настроить, смоделировать или предположить вещи, прежде чем вы сможете, наконец, начать тестировать это. Или вы должны покрыть тонну крайних случаев в вашем огромном блоке кода. Но я могу успокоить вас, сказав, что это не тот случай, когда тестирование управления состоянием выполняется с помощью Redux. Я покажу вам, как вы можете легко проверить необходимые детали, сохранить свои усилия на низком уровне и оставаться ленивым.

Возможно, вы слышали об пирамиде испытаний. Существуют сквозные тесты, интеграционные и модульные тесты. Если вы не знакомы с ними, книга даст вам быстрый и базовый обзор. Модульный тест используется для проверки изолированного и небольшого блока кода. Это может быть одна функция, которая проверяется модульным тестом. Тем не менее, иногда единицы работают хорошо в изоляции, но не работают в сочетании с другими единицами. Они должны быть проверены как группа единиц. Вот где интеграционные тесты могут помочь, рассмотрев, хорошо ли работают единицы. Наконец, что не менее важно, сквозной тест - это симуляция сценария реального пользователя. Это может быть автоматическая настройка в браузере, имитирующая вход пользователя в веб-приложение. В то время как модульные тесты являются быстрыми и простыми в написании и обслуживании, сквозные тесты являются противоположностью этого спектра.

Сколько тестов мне нужно для каждого типа? Вам следует иметь много модульных тестов, чтобы охватить ваши изолированные функции. После этого вы можете провести несколько интеграционных тестов, чтобы понять, что наиболее важные функции работают в комбинации, как и ожидалось. И последнее, но не менее важное: вам может понадобиться всего несколько сквозных тестов для имитации критических сценариев в вашем веб-приложении. Вот и все для общей экскурсии в мире тестирования. Теперь, как это относится к управлению состоянием с Redux?

Redux охватывает стиль функционального программирования. Ваши функции чисты, и вам не нужно беспокоиться о каких-либо побочных эффектах. Функция всегда возвращает один и тот же результат для одних и тех же входных данных. Такие функции легко проверить, потому что вам нужно только дать им входные данные и ожидать результата, потому что есть гарантия отсутсвия побочных эффектов. Это идеально подходит для юнит-тестов, не так ли? В заключение, это делает тестирование управления состоянием при сборке с Redux приятным.

В Redux у вас есть разные группы функций: создатели действий, редукторы, селекторы. Для каждой из этих групп вы можете увидеть шаблон для их вводных данных и результата. Они могут быть применены к тестовому шаблону, который может использоваться в качестве схемы для модульного теста для каждой группы функций.

Шаблон входных данных:

* создатели действий могут иметь дополнительные входные данные, которые становятся их дополнительной полезной нагрузкой
* селекторы могут иметь дополнительные входные данные, который облегчают выбор подсостояния
* редукторы всегда получат предыдущее состояние и действие

Шаблон результата:

* создатели действий всегда будут возвращать объект с типом и дополнительной полезной нагрузкой
* селекторы всегда возвращают подсостояние состояния
* редукторы всегда будут возвращать новое состояние

Шаблон тестирования:

* при вызове создателя действия следует ожидать правильного возвращаемого объекта
* при вызове селектора следует ожидать правильного подсостояния
* при вызове редуктора следует ожидать правильного нового состояния

How does that apply in code? The book will show it in pseudo code, because it will not make any assumption about your testing libraries. Yet it should be sufficient to pick up these patterns for each group of functions (action creators, reducers, selectors) to apply them in your unit tests.
Как это применимо в коде? Книга покажет это в псевдокоде, потому что не будет делать никаких предположений о ваших тестовых библиотеках. Тем не менее, должно быть достаточно подобрать эти шаблоны для каждой группы функций (создатели действий, редукторы, селекторы), чтобы применить их в своих модульных тестах.

*Создатели действий:*

{title="Code Playground",lang="javascript"}
~~~~~~~~
// whereas the payload is optional
const payload = { ... };

const action = doSomething(payload);
const expectedAction = {
  type: 'DO_SOMETHING',
  payload,
};

expect(action).to.equal(expectedAction);
~~~~~~~~

*Селекторы:*

{title="Code Playground",lang="javascript"}
~~~~~~~~
// whereas the payload is optional
const state = { ... };
const payload = { ... };

const substate = getSomething(state, payload);
const expectedSubstate = { ... };

expect(substate).to.equal(expectedSubstate)
~~~~~~~~

*Редукторы:*

{title="Code Playground",lang="javascript"}
~~~~~~~~
const previousState = { ... };
const action = {
  type: 'DO_SOMETHING',
  payload,
};

const newState = someReducer(previousState, action);
const expectedNewState = { ... };

expect(newState).to.equal(expectedNewState);
~~~~~~~~

Эти тестовые шаблоны всегда остаются неизменными для своих аспектов в Redux. Вам нужно только заполнить пробелы. Вы даже можете упростить себе задачу и настроить автоматические фрагменты кода для своего редактора. Например, ввод "rts" (сокращенное обозначение "redux test selector") даст вам сниппет теста селектора. Двумя другими фрагментами могут быть "rtr" (redux test reducer) и "rta" (redux test action). После этого вам нужно только заполнить оставшиеся вещи.

Эти тестовые шаблоны для управления состоянием показывают, насколько простым становится тестирование при работе с четкими ограничениями библиотеки, такой как Redux. Все ведет себя одинаково, это предсказуемо и, следовательно, может быть проверено каждый раз одинаково. При настройке автоматических фрагментов кода вы сэкономите много времени, но при этом получите отличное покрытие тестами для всего управления состоянием. Вы даже можете пойти еще дальше и применить [разработку через тестирование (TDD)](https://en.wikipedia.org/wiki/Test-driven_development), что в основном означает, что вы тестируете перед внедрением.

Есть еще один аккуратный помощник, который может гарантировать, что ваше состояние остается неизменным. Потому что вы никогда не знаете, не изменили ли вы случайно свое состояние, даже если это запрещено в Redux. Я думаю, есть несколько библиотек по этой теме, но я использую [deep-freeze](https://github.com/substack/deep-freeze) в своих тестах, чтобы гарантировать, что состояние (и даже действия) не изменяются

{title="Code Playground",lang="javascript"}
~~~~~~~~
# leanpub-start-insert
import deepFreeze from 'deep-freeze';
# leanpub-end-insert

const previousState = { ... };
const action = {
  type: 'DO_SOMETHING',
  payload,
};

# leanpub-start-insert
deepFreeze(previousState);
# leanpub-end-insert

const newState = someReducer(previousState, action);
const expectedNewState = { ... };

expect(newState).to.equal(expectedNewState);
~~~~~~~~

Вот и все для тестирования различных аспектов при использовании Redux. Это может быть достигнуто с помощью модульных тестов. Вы также можете применять интеграционные тесты, например, для тестирования создателя действий и редуктора вообще. В конце концов, у вас есть план для постоянного тестирования этих функций, и больше нет никаких оснований не проверять ваш код. Если вы хотите погрузиться в настройку тестирования для своего приложения React, ознакомьтесь с этим [Руководство по настройке и использованию тестирования React](https://www.robinwieruch.de/react-testing-tutorial/).

## Обработка ошибок

Тема обработки ошибок редко затрагивается в программировании. Часто сообщество избегает этой темы, и в ней трудно найти здравый смысл. В этой главе дается базовое руководство о том, как можно обеспечить обработку ошибок в приложении Redux.

Обработка ошибок часто нужна при выполнением запросов к API. Вы узнали об асинхронных действиях в Redux, которые можно использовать для подобных побочных эффектов. Но до сих пор не говорилось об обработке ошибок в этих побочных эффектах. Как отловить ошибки и как сделать их видимыми для конечного пользователя вашего приложения?

По сути, ошибка в приложении может быть представлена как состояние. В первую очередьб поэтому тема обсуждается в книге управления состоянием . Например, представьте, что вы получаете элементы todo по запросу с сервера. У вас будет API на стороне сервера, который предоставляет эти элементы todo. После того, как вы получите эти элементы todo из API, вам придется иметь дело с обработкой ошибок, потому что запрос всегда может завершиться неудачей. Следующий запрос возвращает промис JavaScript. Выборка может быть либо успешно разрешена в методе `then()`, либо выдает ошибку в методе `catch()`.

{title="Code Playground",lang="javascript"}
~~~~~~~~
fetch('my/todos/api').then(function(response) {
  return response.json();
}).then(function(todos) {
  // do something with todos
}).catch(function(error) {
  // do something with error
});
~~~~~~~~

При использовании асинхронных действий Redux с Redux Thunk, запрос может находиться в thunk:

{title="Code Playground",lang="javascript"}
~~~~~~~~
function getTodos(dispatch) {
  fetch('my/todos/api').then(function(response) {
    return response.json();
  }).then(function(todos) {
    // do something with todos
  }).catch(function(error) {
    // do something with error
  });
}
~~~~~~~~

Теперь вам нужно сохранить либо задачи, либо ошибку как состояние в вашем хранилище Redux. Вы можете иметь два возможных действия:

{title="Code Playground",lang="javascript"}
~~~~~~~~
const TODOS_FETCH_SUCCESS = 'TODOS_FETCH_SUCCESS';
const TODOS_FETCH_ERROR = 'TODOS_FETCH_ERROR';
~~~~~~~~

Они могут быть использованы в вашем Redux Thunk для хранения обоих возможных результатов:

{title="Code Playground",lang="javascript"}
~~~~~~~~
function getTodos(dispatch) {
  fetch('my/todos/api').then(function(response) {
    return response.json();
  }).then(function(todos) {
    dispatch({ type: TODOS_FETCH_SUCCESS, todos });
  }).catch(function(error) {
    dispatch({ type: TODOS_FETCH_ERROR, error });
  });
}
~~~~~~~~

Редуктор todo теперь может справиться с обоими действиями. С тем, который хранит элементы todo, и тем, который хранит объект ошибки.

{title="Code Playground",lang="javascript"}
~~~~~~~~
const initialState = {
  todos: [],
  error: null,
};

function reducer(state = initialState, action) {
  switch(action.type) {
    case 'TODOS_FETCH_SUCCESS' : {
      return applyFetchTodosSuccess(state, action);
    }
    case 'TODOS_FETCH_ERROR' : {
      return applyFetchTodosError(state, action);
    }
    default : return state;
  }
}

...
~~~~~~~~

На этом, в основном, все для части управления состоянием. В то время как функция `applyFetchTodosError()` запишет объект ошибки в состоянии, функция `applyFetchTodosSuccess()` запишет список задач. Кроме того, функция успеха должна была бы снова сбросить свойство error в состоянии null, поскольку представьте, что вы сделаете второй запрос после того, как первый запрос не будет выполнен. Когда второй запрос был успешным, вы хотите сохранить элементы todo, но сбросить состояние ошибки.

В вашем слое представления, в зависимости от состояния задачи, вы можете решить, показывать ли сообщение об ошибке, потому что в состоянии задачи есть объект ошибки, или отображать список задач. Когда отображается сообщение об ошибке, вы можете предоставить своему конечному пользователю кнопку для повторной выборки задач. Когда второй запрос успешен, объект ошибки устанавливается в null, и вместо этого элементы todo устанавливаются в состояние. Слой представления теперь может отображать список элементов todo.

В конце концов, в Redux нет никакого волшебства за обработкой ошибок. Всякий раз, когда возникает ошибка, вы должны сохранить ее в своем состоянии. Когда уровень представления замечает ошибку в состоянии, он может использовать условный рендеринг, чтобы показать сообщение об ошибке вместо предполагаемого результата.