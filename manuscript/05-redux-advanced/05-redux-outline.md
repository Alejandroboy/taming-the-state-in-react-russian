# Описание экосистемы Redux

Изучив основы и передовые методы в Redux и применив их самостоятельно в приложении, вы готовы исследовать экосистему Redux. Экосистема Redux огромна и не может быть рассмотрена в одной книге. Тем не менее, эта глава пытается наметить различные пути, по которым вы можете исследовать мир Redux. Помимо описания этих различных путей, будет также рассмотрена пара тем, чтобы дать вам богатый набор инструментов при использовании Redux.

Прежде чем оставить вас в покое с последней главой, посвященной Redux, я хочу, чтобы вы узнали о [этом репозитории](https://github.com/markerikson/redux-ecosystem-links) Марка Эриксона. Это категоризированный список дополнений, библиотек и статей, связанных с Redux. Если вы застряли в какой-то момент, хотите найти решение для вашей проблемы или просто хотите узнать об экосистеме, посмотрите репозиторий. В противном случае, я призываю вас присоединиться к официальной [Slack Group](https://slack-the-road-to-learn-react.wieruch.com/) для получения дальнейших рекомендаций.

## Redux DevTools

Redux DevTools важны для многих разработчиков при реализации приложений Redux. Он улучшает рабочий процесс разработки Redux, предлагая богатый набор функций, таких как проверка состояния и полезной нагрузки, путешествия во времени и оптимизации в реальном времени.

Как это работает? В принципе, у вас есть два варианта использования Redux DevTools. Либо вы интегрируете его непосредственно в свой проект, используя пакет с npm, либо устанавливаете официальное расширение для браузера. В то время как первый поставляется с настройкой реализации в вашем приложении, последний может быть просто установлен для вашего браузера без изменения вашей реализации.

Наиболее очевидной особенностью является проверка действий и состояния. Вместо того чтобы использовать [redux-logger](https://github.com/evgenyrodionov/redux-logger), вы можете использовать Redux DevTools, чтобы получить представление об этой информации. Вы можете следить за каждым изменением состояния, проверяя действие и состояние.

Еще одна отличная особенность - возможность путешествовать во времени. В Redux вы отправляете действия и путешествуете от одного состояния к другому. Redux DevTools позволяет вам путешествовать во времени, отменяя действия. Например, таким образом вам больше не нужно будет перезагружать браузер, чтобы выполнить набор действий, чтобы перейти к определенному состоянию приложения. Вы можете просто изменить действия между ними, используя Redux DevTools. Вы можете отследить, какое действие привело к какому состоянию.

Кроме того, вы можете сохранить свое состояние Redux при перезагрузке страницы с помощью Redux DevTools. Таким образом, вам больше не нужно выполнять все необходимые действия, чтобы перейти в определенное состояние. Вы просто перезагрузите страницу и сохраните то же состояние приложения. Это позволяет вам отлаживать ваше приложение при наличии одного определенного состояния приложения.

Тем не менее, есть и другие полезные функции, которые могут вам пригодиться при разработке приложения Redux. Всю информацию о Redux DevTools вы можете найти в [официальном репозитории](https://github.com/gaearon/redux-devtools).

## Connect Revisited

В одной из предыдущих глав вы связали свой слой представления со слоем состояния с помощью [react-redux](https://github.com/reactjs/react-redux). Там вы использовали шаблон провайдера в React, чтобы сделать состояние доступным для всего слоя представления.

Компоненты высшего порядка `connect` позволили вам подключить хранилище Redux к любому компоненту. Наиболее часто используемые два аргумента - это `mapStateToProps()` и `mapDispatchToProps()` для компонента подключения более высокого порядка. В то время как первый дает доступ к состоянию, последний дает доступ к действиям, которые будут направлены для манипулирования состоянием.

Однако у `connect` есть еще два необязательных аргумента, которые не должны остаться не озвученными в этой книге.

Третий аргумент называется `mergeProps()`. В качестве аргументов он получает результат от  `mapStateToProps()`, `mapDispatchToProps()` и родительских пропсов: `mergeProps (stateProps, dispatchProps, ownProps)`. Функция возвращает пропсы как объект для обернутого компонента. По сути, он дает вам промежуточный уровень, чтобы смешать `stateProps` и` dispatchProps`, прежде чем они достигнут обернутого компонента. Тем не менее, он используется редко. Часто при смешивании состояния и действий на этом уровне это связано с плохой архитектурой состояния. Вы должны спросить себя, можно ли что-то изменить, чтобы избежать этого промежуточного слоя.

Четвертый аргумент называется `options`. Это объект для настройки подключения компонента высокого порядка. Он поставляется с такими дополнительными свойствами: `pure`,` areStatesEqual()`, `areOwnPropsEqual()`, `areMergedPropsEqual()`. Как это работает в целом? Когда первый аргумент, свойство `pure`, имеет значение true, компонент подключения высокого порядка будет избегать повторной визуализации представления и избегать вызовов его аргументов `mapStateToProps()`, `mapDispatchToProps() ` и `mergeProps()`. Но только когда проверки на равенство `areStatesEqual()`, `areOwnPropsEqual()`, `areMergedPropsEqual()` остаются равными на основе соответствующих проверок равенства. Эти проверки на равенство выполняются для предыдущего состояния и пропсов и обновленного состояния и пропсов. Эти проверки на равенство могут быть изменены в опциях `areStatesEqual`, `areOwnPropsEqual`, `areMergedPropsEqual`. В противном случае они имеют проверку на равенство по умолчанию.

В конце концов, `options` - это чистая оптимизация производительности. Это не часто используется при разработке приложений Redux. По сути, вы можете установить для свойства `pure` значение true, чтобы избежать повторного рендеринга и других вычислений аргументов компонента высшего порядка `connect`. Но он поставляется с определенными проверками равенства по умолчанию, которые можно настроить. Кроме того, основное предположение заключается в том, что обернутый компонент является чистым компонентом и не зависит от каких-либо других данных о побочных эффектах.

Если вы хотите снова прочитать про компонент высокого порядка `connect`, вы можете обратиться к [официальному репозиторию react-redux](https://github.com/reactjs/react-redux) и найти главу `connect`.

## Сокращенные действия и редукторы

Redux сделал управление состоянием предсказуемым с четкими ограничениями. Тем не менее, эти ограничения сопровождаются большим количеством кода для управления действиями и редукторами. Есть люди, которые утверждают, что написание кода Redux является многословным. Вот почему в Redux существуют служебные библиотеки для сокращения стандартного кода. Один из них называется [redux-actions](https://github.com/acdlite/redux-actions).

Библиотека пытается сделать ваши действия и редукторы краткими. Он поставляется с тремя методами: `createAction()`, `handleAction()` и `combActions()`. Книга даст вам краткий обзор первых двух методов.

Метод `createAction()` является утилитой для создателей действий. Чтобы быть более конкретным, метод должен быть назван: `createActionCreator()`. Единственным обязательным аргументом для метода является тип действия.

{title="Code Playground",lang="javascript"}
~~~~~~~~
import { createAction } from 'redux-actions';

const doAddTodo = createAction('TODO_ADD');
~~~~~~~~

`doAddTodo()` является создателем действий. Он использует указанный тип действия 'TODO_ADD'. При его использовании вы можете передавать полезную нагрузку при необходимости. Он автоматически распределяется под свойством полезной нагрузки.

{title="Code Playground",lang="javascript"}
~~~~~~~~
const action = doAddTodo({ id: '0', name: 'learn redux', completed: false });

// action: {
//   type: 'TODO_ADD',
//   payload: {
//     id: '0',
//     name: 'learn redux',
//     completed: false
//   }
// }
~~~~~~~~

Метод `handleAction()` является утилитой для редукторов. Он выравнивает типы действий с редукторами, в то время как инструкция switch больше не требуется. Он принимает тип действия в качестве аргумента и функцию-редуктор для обработки входящего действия. В качестве третьего аргумента, он принимает начальное состояние.

{title="Code Playground",lang="javascript"}
~~~~~~~~
import { handleAction } from 'redux-actions';

handleAction('TODO_ADD', applyAddTodo, {});

function applyAddTodo(state, action) {
  // ...
  // return new state
}
~~~~~~~~

Два метода `createAction()` и `handleAction()` имеют родственные методы для использования, создания и обработки нескольких действий: `createActions()` и `handleActions()`. При определении редуктора имеет особый смысл отобразить несколько типов действий на несколько обработчиков.

{title="Code Playground",lang="javascript"}
~~~~~~~~
import { handleActions } from 'redux-actions';

const reducer = handleActions({
  TODO_ADD: applyAddTodo,
  TODO_TOGGLE: applyToggleTodo,
}, initialState);
~~~~~~~~

Как видите, это гораздо более кратко, чем определение редукторов в простом JavaScript с помощью оператора switch.

{title="Code Playground",lang="javascript"}
~~~~~~~~
function reducer(state = initialState, action) {
  switch(action.type) {
    case 'TODO_ADD' : {
      return applyAddTodo(state, action);
    }
    case 'TODO_TOGGLE' : {
      return applyToggleTodo(state, action);
    }
    default : return state;
  }
}
~~~~~~~~

Недостатком использования библиотеки является то, что она скрывает, как Redux работает с простым JavaScript. Новичкам может быть сложно понять, что происходит при использовании таких служебных библиотек с самого начала, не понимая, как работают действия и редукторы в Redux.

Библиотека - это всего лишь небольшая вспомогательная поддержка для Redux, но многие используют ее. Вы можете прочитать все об этом в [официальной документации](https://github.com/acdlite/redux-actions).

## React Redux библиотеки

Помимо библиотеки [react-redux](https://github.com/reactjs/react-redux), которая склеивает ваш слой представления и состояния, существуют и другие библиотеки, которые можно использовать, когда вы уже используете React и Redux. Обычно эти библиотеки предоставляют вам компоненты высшего порядка React, которые связаны с хранилищем Redux. Таким образом, вам не нужно беспокоиться об управлении состоянием, когда оно защищено от вас.

Например, при использовании HTML-форм в React часто бывает сложно отслеживать состояние каждого элемента ввода в локальном компоненте. Более того, вы часто сталкиваетесь с валидацией этих форм. Библиотека [redux-form](https://github.com/erikras/redux-form) помогает отслеживать состояние формы не в локальном состоянии, а в хранилище Redux. Это позволяет получить доступ и обновить состояние формы через компонент высшего порядка, который подключен к хранилищу Redux. Кроме того, он поддерживает вас в валидации вашего состояния формы, прежде чем пользователь может отправить его.

Другим примером может быть компонент таблицы в React. Простой компонент таблицы в React может быть легко написан самостоятельно. Но как насчет определенных функций, таких как сортировка, фильтрация или разбиение на страницы? Тогда это становится трудным, потому что вам придется управлять состоянием каждого инициализированного компонента таблицы. Существует несколько библиотек, которые помогут вам реализовать таблицы в React и склеить их с хранилищем Redux. Например, для таких случаев можно использовать [react-redux-composable-list](https://github.com/SmallImprovements/react-redux-composable-list).

Существует множество библиотек, которые уже абстрагируют вас от управления состоянием при использовании общих компонентов, таких как формы или таблицы. Опять же, вы можете заглянуть в [этот репозиторий](https://github.com/markerikson/react-redux-links), чтобы ознакомиться с различными из этих библиотек. Имеет смысл использовать проверенные в сражениях абстракции в качестве библиотек, прежде чем применять их самостоятельно.

## Маршрутизация с Redux

В одностраничных приложениях вы будете вводить маршрутизацию в конце концов. В React существует одна предпочтительная библиотека для маршрутизации: [React Router](https://github.com/ReactTraining/react-router). Есть и другие библиотеки маршрутизации для других одностраничных приложений. Эти решения помогут вам перейти от URL к URL без перезагрузки страницы. Так работают одностраничные приложения. Вы получаете приложение только один раз, но отслеживаете состояние даже при маршрутизации с URL на URL. Таким образом, маршруты в ваших URL тоже состояния. Но управляется ли это в хранилище Redux?

Здравый смысл при использовании маршрутизации в Redux заключается в том, что маршрутизатор обрабатывает URL, а Redux обрабатывает состояние. Там нет взаимодействия между ними. Например, если вы решили сохранить свой фильтр видимости `SHOW_ALL` в своем URL (domain.com?filter=SHOW_ALL) вместо своего хранилища Redux, это нормально. Вам нужно будет только получить состояние из URL, а не из магазина Redux. Так что это зависит от вашей собственной настройки. В конце концов, маршрутизатор содержит единственный источник правды для состояния URL, а хранилище Redux содержит единственный источник правды для состояния приложения. Вы можете прочитать больше об этой теме в [официальной документации](http://redux.js.org/docs/advanced/UsageWithReactRouter.html) Redux.

## Типизированный Redux

JavaScript по своей природе является нетипизированным языком. В вашей карьере вы часто будете сталкиваться с ошибками, которые могли бы быть предотвращены безопасностью типов. В Redux безопасность типов может иметь большой смысл, потому что вы можете точно определить, какие типы входят в ваши действия, редукторы или состояния. Вы можете определить, что действие, создающее элемент todo, будет иметь свойство `name` с типом String и свойство` complete` с типом Boolean. Каждый раз, когда вы передаете неправильное типизированное значение для этих свойств для создания элемента todo, вы получаете сообщение об ошибке во время компиляции вашего приложения. Вам не нужно ждать, пока ваше приложение запустится, чтобы понять, что вы передали неверное значение своему действию. Не будет ошибок во времемя выполнения, если вы уже можете устранить эти ошибки во время компиляции.

Типизированный JavaScript может быть многословным решением при работе над недолговечными или простыми проектами. Но при работе с большой кодовой базой, где код должен быть поддерживаемым, рекомендуется использовать средство проверки типов. Это упрощает рефакторинг и добавляет ряд преимуществ для разработчиков благодаря интеграции с редактором и IDE.

Существуют два основных решения, постепенно использующих JavaScript в качестве типизированного языка: Flow (Facebook) и TypeScript (Microsoft). В то время как первый имеет наибольшее влияние в сообществе React, последний хорошо зарекомендовал себя среди других фреймворков и библиотек.

Как бы выглядела программа проверки типа Flow при использовании в Redux? Например, в редукторе todo состояние может быть определено типом:

{title="Code Playground",lang="javascript"}
~~~~~~~~
# leanpub-start-insert
type Todo = {
  id: string,
  name: string,
  completed: boolean,
};

type Todos = Array<Todo>;

function todoReducer(state: Todos = [], action) {
# leanpub-end-insert
  switch(action.type) {
    case ADD_TODO : {
      return applyAddTodo(state, action);
    }
    default : return state;
  }
}
~~~~~~~~

Теперь, когда действие приводит к состоянию, которое не определено его определением типа, вы получите ошибку во время компиляции вашего приложения. Кроме того, вы можете использовать плагины для своего редактора или IDE, чтобы на ранних этапах получить обратную связь о том, что что-то не так с вашим действием или редуктором. Как и в предыдущем примере, показана безопасность типов для редукторов, вы можете применить то же самое для создателей и селекторов действий. Все может быть проверено типом. Вы можете прочитать больше о [Flow на его официальном сайте](https://flow.org/).

## Redux на сервере

Рендеринг на стороне сервера используется для визуализации начальной загрузки страницы с сервера. Каждое дальнейшее взаимодействие с пользователем осуществляется на стороне клиента. Например, это полезно для SEO, потому что, когда веб-сканер посещает ваш сайт, он может извлечь все приложение, не обращая внимание на выполнение JavaScript на стороне клиента. Он получает все приложение с его начальным состоянием. Начальное состояние уже может быть данными, которые выбираются из базы данных. В React, а также и в других одностраничных приложениях, есть решения для рендеринга на стороне сервера. Однако внедрение рендеринга на стороне сервера сопряжено с рядом проблем. Одна из этих задач - управление состоянием.

Когда начальная страница отображается на стороне сервера, начальное состояние также должно быть отправлено как ответ клиенту. Клиент в ответ будет использовать начальное состояние. Например, представьте, что вы хотите загрузить данные из базы данных, прежде чем отправлять ответ с сервера клиенту. Каким-то образом вам придется поместить эти данные в ответ рядом с вашим приложением на стороне сервера. После этого клиент может использовать ответ для визуализации приложения и уже будет иметь начальное состояние, которое поступает из базы данных. Если данные не были отправлены в первоначальном запросе к серверу, клиент должен был бы получить их снова.

В Redux вы можете инициализировать хранилище Redux где угодно. Вы можете инициализировать его на стороне клиента, чтобы получить доступ к состоянию и управлять им, а также на стороне сервера, чтобы предоставить вашему приложению начальное состояние. Начальное состояние будет помещено в хранилище Redux до отправки серверного ответа клиентскому приложению. Но как это работает? Хранилище Redux на стороне клиента - это синглтон. Существует только один экземпляр хранилища Redux. На стороне сервера хранилище Redux не является синглтоном. Каждый раз, когда делается запрос на стороне сервера, он инициализирует новый экземпляр хранилища Redux. Хранилище Redux может быть заполнено начальным состоянием до того, как ответ на стороне сервера будет отправлен клиенту.

Рендеринг на стороне сервера и управление состоянием открывают совершенно новую тему. Вот почему книга не охватывает тему, а лишь указывает вам правильное направление. Вы можете прочитать больше о теме в [официальной документации Redux](http://redux.js.org/docs/recipes/ServerRendering.html).
