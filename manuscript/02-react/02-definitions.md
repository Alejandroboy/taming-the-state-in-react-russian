## Определения

Перед тем, как мы углубимся в управление состояниями, в этой главе приведены общие определения и определения для управления состояниями, чтобы создать общий словарь управления состояниями для этой книги. Это должно помочь вам без труда следовать интруциям из книги, не оставляя места для путаницы.

### Чистые функции

Чистые функции - это понятие из парадигмы функционального программирования. Парадигма гласит, что чистая функция всегда возвращает один и тот же результат, при одних и тех же вводных данных. Между ними нет слоя, который мог бы изменить результат в процессе выполнения, пока входные данные не меняются. Слой между ними, который может изменить результат, называется **побочным эффектом**. Таким образом, чистые функции не имеют побочных эффектов. Двумя основными преимуществами этих чистых функций являются предсказуемость и тестируемость.

### Неизменяемость

Неизменность - это тоже концепция функционального программирования. Это концепция говорит о том, что структура данных остается неизменна, ее нельзя изменять. Когда есть необходимость изменить неизменяемую структуру данных, например, объект, вы всегда возвращаете новый объект. Вместо того, чтобы изменять объект, вы должны создать новый объект на основе старого объекта и ваших изменений. У старого и нового объекта будут свои экземпляры.

Неизменяемая структура данных имеют преимущество предсказуемости. Например, совместное использовании объекта через все приложение может привести к ошибкам при непосредственном изменении объекта, поскольку каждая заинтересованная сторона имеет ссылку на этот потенциально измененный объект. Было бы непредсказуемо, что произойдет, когда объект изменится, и несколько заинтересованных сторон, таких как компоненты пользовательского интерфейса, зависят от этого объекта. В растущем приложении трудно контролировать места, где объект используется в настоящее время по его ссылке.

Примечание: провоположностью неизменности называется изменяемость. Это говорит о том, что объект может быть изменен.

### Состояние

Состояние - широкое понятие в современных приложениях. Говоря о **состоянии приложения**, это может быть что угодно, что нужно сохранить и **чем можно управлять (создавать, обновлять, удалять)** в приложении. Состояние может быть **сторонними данные**, которые извлекаются из бэкенда приложения или **просматриваемыми данными**, которые сушествуют только на стороне клиента приложения.

Я буду ссылаться на первое как **состояние организации**, а второе - на **состояние представления**. Состояние организации - это данные, полученные из бекэнда приложения. Это может быть список авторов или объект пользователя, описывающий пользователя, который в данный момент вошел в приложение. С другой стороны, состояние представления не нужно хранить в бэкэнде. Он используется, когда вы открываете модальное или переключаетесь из режима предварительного просмотра в режим редактирования.

Говоря об управлении состоянием, подразумевая создание, обновление и удаление состояния, мы объединяем их под общим термином управления состоянием. Тем не менее, управление состоянием является гораздо более широкой темой. Хотя упомянутые действия являются низкоуровневыми операциями, почти на уровне реализации, архитектура, распостраненные практики и шаблоны управления состоянием остаются абстрактными. **Управление состоянием** включает в себя все эти темы, чтобы сохранить состояние вашего приложения.

#### Размер состояния

Состоянием может быть отдельным объектом или одним большим составным объектом. Если говорить о состоянии представления, которое определяет только, является ли всплывающее окно открытым или закрытым, это **локальный объект состояния**. Когда все состояние приложения может быть получено из одного составного объекта, который включает в себя все объекты локального состояния, он называется **глобальным объектом состояния**. Часто глобальный объект состояния подразумевает, что он доступен отовсюду.

Само состояние можно разделить на **локальное состояние** и **глобальное состояние**. Управление этим состоянием называется **управление локальным состоянием** и **управление глобальным состоянием**.

#### Локальное состояние

Название локального состояния широко распространено в сообществе веб-разработчиков. Другим термином может быть **внутренне состояние компонента**. Локальное состояние связано с компонентами или иерархиями компонентов. Оно живет в слое представления. Оно не хранится где-то еще за пределами слоя представления. Вот почему он называется локальным состоянием, потому что оно расположен на одном уровне с компонентом.

В React локальное состояние управляется с помощью `this.state` и `this.setState()`. Но оно может управляться и использоваться на другом уровне представления или решениях SPA. Книга объясняет и демонстрирует локальное состояние в React перед тем, как погрузиться в сложное управление состоянием с внешними библиотеками, такими как Redux и MobX.

#### Глобальное состояние

Я не могу сказать, что в сообществе веб-разработчиков широко принято назвать это глобальным состоянием. Однако в какой-то момент вам нужен термин, чтобы отличить его от локального состояния. Вот почему я часто называю это глобальным состоянием. В других ресурсах вы можете найти его как **внешнее состояние**, потому что он находится за пределами компонентов пользовательского интерфейса или за пределами уровня представления.

Чаще всего глобальное состояние делегируется библиотекам, которые не зависят от библиотеки или фреймворка и, следовательно, не зависят от уровня представления. Но чаще всего они обеспечивают мост для доступа и изменения состояния из уровня представления. При использовании только локального состояния в масштабирующем приложении вы будете распределять слишком много состояний вдоль ваших компонентов в слое представления. Однако в какой-то момент вы захотите разделить слой представления и слой состояния, потому что состояние станет слишком сложным. Вот тогда в игру и вступает глобальное состояние.

Две библиотеки, известные управлением глобальным состоянием, называются Redux и MobX. Обе библиотеки будут объяснены, обсуждены и продемонстрированы в этой книге.

#### Представление состояния

Поскольку локальное состояние связано только с экземпляром компонента, только сам компонент знает, что эти свойства являются состоянием. Тем не менее, компонент может поделиться состоянием со своими дочерними компонентами. В React дочерние компоненты не знают, что эти свойства находятся в состоянии. Они получают эти свойства только в качестве пропса.

С другой стороны, глобальное состояние часто является глобально доступным. Теоретически, состояние может быть доступно каждому компоненту. Часто распостраненной практикой является не предоставлять каждому компоненту доступ к глобальному состоянию, поэтому от разработчика зависит какие компоненты будут связанны с глобальным объектом состояния. Все остальные компоненты остаются в неведении о состоянии и получают свойства только в качестве реквизита для воздействия на них.