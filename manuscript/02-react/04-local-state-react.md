## Локльное состояние в React

Книга использует React в качестве слоя представления для демонстрации локального состояния в веб-приложении. В следующей главе основное внимание уделяется локальному состоянию в React, прежде чем перейти к глобальному управлению состоянием с помощью Redux и MobX. Как уже упоминалось, концепция локального состояния должна быть известна и в других решениях SPA и, следовательно, должна применяться в этих решениях.

Итак, как выглядит локальное состояние в React компоненте?

{title="Code Playground",lang="javascript"}
~~~~~~~~
import React from 'react';

class Counter extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      counter: 0
    };
  }

  render() {
    return (
      <div>
        <p>{this.state.counter}</p>
      </div>
    );
  }
}
~~~~~~~~

В примере показан компонент `Counter`, который имеет свойство `counter` в локальном объекте состояния. Он определяется со значением `0`, когда компонент создается его конструктором. Кроме того, свойство counter из локального объекта состояния используется в методе рендеринга компонента для отображения его текущего значения.

Пока нет манипуляций с состоянием. Прежде чем вы начнете манипулировать состоянием, вы должны знать, что вам никогда не разрешается изменять его напрямую: `this.state.counter = 1`. Это было бы прямым изменением. Вместо этого вы должны использовать компонент API React для явного изменения состояния с помощью метода `this.setState()`. Он сохраняет объект состояния неизменным, поскольку объект состояния не изменяется, а создается его новая измененная копия.

{title="Code Playground",lang="javascript"}
~~~~~~~~
import React from 'react';

class Counter extends React.Component {
  constructor(props) {
    ...

# leanpub-start-insert
    this.onIncrement = this.onIncrement.bind(this);
    this.onDecrement = this.onDecrement.bind(this);
# leanpub-end-insert
  }

# leanpub-start-insert
  onIncrement() {
    this.setState({
      counter: this.state.counter + 1
    });
  }

  onDecrement() {
    this.setState({
      counter: this.state.counter - 1
    });
  }
# leanpub-end-insert

  render() {
    ...
  }
}
~~~~~~~~

Методы класса могут использоваться в методе `render()` для запуска локальных изменений состояния.

{title="Code Playground",lang="javascript"}
~~~~~~~~
import React from 'react';

class Counter extends React.Component {
  ...

  render() {
    return (
      <div>
        <p>{this.state.counter}</p>
# leanpub-start-insert
        <button type="button" onClick={this.onIncrement}>
          Increment
        </button>
        <button type="button" onClick={this.onDecrement}>
          Decrement
        </button>
# leanpub-end-insert
      </div>
    );
  }
}
~~~~~~~~

Теперь обработчик кнопки `onClick` должен вызывать методы класса для изменения состояния путем увеличения или уменьшения значения счетчика. Затем функция обновления с помощью `this.setState()` выполняет **частичное слияние** объектов. Что означает частичное слияние? Представьте, что у вас есть следующее состояние в вашем компоненте, два массива с объектами:

{title="Code Playground",lang="javascript"}
~~~~~~~~
this.state = {
  authors: [...],
  articles: [...],
};
~~~~~~~~

При обновлении состояния только частично, например, авторов, другая часть, в данном случае статьи, остается без изменений.

{title="Code Playground",lang="javascript"}
~~~~~~~~
this.setState({
  authors: [
    { name: 'Robin', id: '1' }
  ]
});
~~~~~~~~

Он только обновляет массив `authors` новым массивом, не затрагивая массив `articles`. Это называется мелким слиянием. Это упрощает локальное управление состояниями, так что вам не нужно следить за всеми свойствами одновременно в локальном состоянии.

### Компоненты с состоянием и без

Локальное состояние может использоваться только в React компонентах основанных на классах ES6. Компонент становится **компонентом с состоянием**, когда используется состояние. В противном случае его можно назвать **компонентом без состояния**, даже если он все еще является React компонентом основанным на классах ES6. Это может быть в том случае, если вам все еще нужно использовать методы жизненного цикла React.

С другой стороны, **функциональные компоненты без состояния**  как следует из названия не имеют состояния, потому что, они являются только функциями. Они получают входные данные как пропсы и возвращают выходные данные как JSX. В компоненте без состояния состояние может передаваться только как пропсы родительского компонента. Тем не менее, функциональный компонент без сохранения состояния не знает о том что пропс это состоянии в родительском компоненте. Кроме того, функции обратного вызова могут быть переданы функциональному компоненту без сохранения состояния, чтобы иметь косвенный способ изменения состояния в родительском компоненте снова. Функциональный компонент без сохранения состояния Counter может выглядеть следующим образом:

{title="Code Playground",lang="javascript"}
~~~~~~~~
import React from 'react';

function CounterPresenter(props) {
  return (
    <div>
      <p>{props.counter}</p>
      <button type="button" onClick={props.onIncrement}>
        Increment
      </button>
      <button type="button" onClick={props.onDecrement}>
        Decrement
      </button>
    </div>
  );
}
~~~~~~~~

Теперь в этом функциональном компоненте без состояния будут использоваться только пропсы родительского компонента. Будет отображаться пропс `counter`, и для кнопок будут использоваться две функции обратного вызова `onIncrement()` и `onDecrement()`. Однако функциональный компонент без сохранения состояния не знает, являются ли переданные свойства состоянием, пропсом или другими производными свойствами. Источник пропса не обязательно должен находиться в родительском компоненте, он может находиться где-то выше в дереве компонентов. Родительский компонент будет только передавать свойства или производные свойства по пути. Кроме того, компонент не знает, что делают функции обратного вызова. Он не знает, что они изменяют локальное состояние родительского компонента.

В конце концов, функции обратного вызова в компоненте без состояния позволят изменить состояние где-то выше в одном из родительских компонентов. После того, как состояние изменится, новое состояние снова передается как пропс в дочерний компонент. Новый пропс `counter` будет отображаться правильно, потому что метод рендеринга дочернего компонента запускается снова с входящими измененными пропсами.

Этот пример показывает, как локальное состояние может передаваться от одного компонента к дереву компонентов. Чтобы завершить пример с функциональным компонентом без состояния, давайте быстро покажем, как будет выглядеть потенциальный родительский компонент, который управляет локальным состоянием. Это React компонент основанный на классах ES6 для сохранения состояния.

{title="Code Playground",lang="javascript"}
~~~~~~~~
import React from 'react';

class CounterContainer extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      counter: 0
    };

    this.onIncrement = this.onIncrement.bind(this);
    this.onDecrement = this.onDecrement.bind(this);
  }

  onIncrement() {
    this.setState({
      counter: this.state.counter + 1
    });
  }

  onDecrement() {
    this.setState({
      counter: this.state.counter - 1
    });
  }

  render() {
    return <CounterPresenter
      counter={this.state.counter}
      onIncrement={this.onIncrement}
      onDecrement={this.onDecrement}
    />
  }
}
~~~~~~~~

Не случайно суффиксами в именовании обоих компонентов «Counter» являются «Container» и «Presenter». Он называется [шаблон компонентов контейнера и представления](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0). Чаще всего он применяется в React, но может существовать и в других компонентно-ориентированных библиотеках и средах. Если вы никогда не слышали об этом, я рекомендую прочитать статью ссылке. Это широко используемый шаблон, где компонент контейнера это «Как все работает», а компонент презентатора «Как все выглядит». В нашем случае компонент контейнера заботится о состоянии, в то время как компонент представления отображает только значение счетчика и предоставляет несколько обработчиков кликов, не зная, что эти обработчики кликов манипулируют состоянием. Обратите внимание, что в указанной статье компонент представления называется компонентом презентации. Ради удобства я сократил название с презентационного компонента (`presentational`) до компонента представления (`presenter`).

 Компоненты контейнера являются идеальными кандидатами для управления состоянием, в то время как компоненты представления только отображают его и воздействуют на функции обратного вызова. Эти компоненты контейнеров вы встретите чаще в книге, когда будете иметь дело с понятиями компонентов более высокого порядка, которые потенциально могут управлять локальным состоянием и связанными компонентами.

### Пропс vs. Состояния

В предыдущем примере было ясно, что в React существует разница между состоянием и пропсом. Когда свойства передаются дочернему компоненту, будь то состояние, пропс или производные свойства, дочерний компонент не знает о типе свойств. Он видит входящие свойства в качестве пропса. Это прекрасно, потому что компонент не должен заботиться о типе свойств. Он должен использовать их только как простой пропс.

Пропс поступает из родительского компонента. В родительском компоненте эти пропсы могут быть состоянием, пропсами или производными свойствами. Это зависит от родительского компонента, если он сам управляет свойствами (состоянием), получает свойства от самого родительского компонента (пропса) или получает новые свойства от входящих пропсов, поступающих от его родительского компонента по пути (производный свойства).

В конце концов, вы не можете изменить пропс. Пропсы - это только свойства, передаваемые из родительского компонента в дочерний компонент. С другой стороны, локальное состояние живет в самом компоненте. Вы можете получить к нему доступ с помощью `this.state`, изменить его с помощью `this.setState()` и передать его в качестве пропса дочерним компонентам.

Когда один из этих объектов изменяется, будь то пропсы, исходящие от родительского компонента, или состояние в компоненте, будут запущены методы обновления жизненного цикла компонента. Одним из этих методов жизненного цикла является метод `render ()`, который обновляет экземпляр вашего компонента на основе пропсов и состояния. Правильные значения будут использоваться и отображаться после запуска обновления в вашем компоненте.

Когда вы начинаете использовать React, может быть трудно определить пропс это или состояние. Лично мне нравятся [правила в официальной документации React](https://reactjs.org/docs/thinking-in-react.html) для определения состояния и пропсов:

* Свойства передаются от родительского компонента? Если да, высока вероятность того, что они не являются состоянием. Хотя возможно сохранить пропс как состояние, вариантов использования мало. Следует избегать сохранения пропсов как состояния. Используйте их в качестве пропсов, как они есть.

* Изменяется ли свойства с течением времени? Если да, они не должны быть состоянием, потому что они не модифицируются.

* Свойства выводятся из локального состояния или пропса? Если да, они вам не нужны как состояние, потому что вы можете их получить. Если вы выделили дополнительное состояние, этим состоянием нужно управлять, и оно может перестать синхронизироваться, если в какой-то момент вы не сможете получить новые свойства.

### Состояние формы

Распространенным вариантом использования в приложениях является использование HTML-форм. Например, вам может потребоваться получить информацию о пользователе, такую как имя или номер кредитной карты, или отправить поисковый запрос во внешний API. Формы используются везде в веб-приложениях.

Есть два способа использовать формы в React. Вы можете использовать атрибут ref или локальное состояние. Рекомендуется использовать подход локального состояния, поскольку атрибут ref зарезервирован только для нескольких случаев использования. Если вы хотите прочитать об этих случаях использования атрибута ref, я рекомендую вам прочитать следующую статью: [Когда использовать Ref на DOM элементе в React](https://www.robinwieruch.de/react-ref-attribute-dom-node/).

Следующий фрагмент кода является демонстрацией того, как можно использовать состояние формы с помощью атрибута ref. После этого фрагмент кода будет подвергнут рефакторингу для использования локального состояния, что в любом случае является наилучшей практикой.

{title="Code Playground",lang="javascript"}
~~~~~~~~
import React from 'react';

class Search extends React.Component {
  constructor(props) {
    super(props);

    this.onSubmit = this.onSubmit.bind(this);
  }

  onSubmit(event) {
    const { value } = this.input;

    // do something with the search value
    // e.g. propagate it up to the parent component
    this.props.onSearch(value);

    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.onSubmit}>
        <input
          ref={node => this.input = node}
          type="text"
        />
        <button type="submit">
          Search
        </button>
      </form>
    );
  }
}
~~~~~~~~

Значение из инпута извлекается с использованием ссылки на DOM элемент. Это происходит в методе `onSubmit()`. Ссылка создается с помощью атрибута ref в методе `render()`.

Теперь давайте посмотрим, как использовать локальное состояние, чтобы использовать распостраненные практики, без использоваия зарезервированного атрибута ref.

{title="Code Playground",lang="javascript"}
~~~~~~~~
import React from 'react';

class Search extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      query: ''
    };

    this.onChange = this.onChange.bind(this);
    this.onSubmit = this.onSubmit.bind(this);
  }

  onChange(event) {
    const { value } = event.target;

    this.setState({
      query: value
    });
  }

  onSubmit(event) {
    const { query } = this.state;

    // do something with the search value
    // e.g. propagate it up to the parent component
    this.props.onSearch(query);

    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.onSubmit}>
        <input
          onChange={this.onChange}
          type="text"
        />
        <button type="submit">
          Search
        </button>
      </form>
    );
  }
}
~~~~~~~~

Вам больше не нужно использовать атрибут ref. Вы можете решить проблему, используя только местное состояние. Пример демонстрирует это только с одним полем ввода, но также может использоваться с несколькими полями ввода. Вам нужно будет только выделить больше свойств, по одному для каждого поля ввода, в локальном состоянии.

### Контролируемые компоненты

Предыдущий пример использования состояния формы с локальным состоянием имеет один недостаток. Он не использует **контролируемые компоненты**. Поле ввода HTML содержит свое собственное состояние. Когда вы вводите значение в поле ввода, узел DOM знает о значении. Это естественное поведение элементов HTML, иначе они не будут работать сами по себе.

Однако значение живет и в вашем локальном состоянии. Знчение есть как в нативном состоянии узла DOM, так и в локальном состоянии. Но вы хотите использовать единый источник правды. Рекомендуется перезаписывать нативное состояние узла DOM, используя атрибут `value` в элементе HTML и значение из локального состояния из компонента React.

Давайте снова рассмотрим предыдущий пример. Поле ввода не имеет назначенного атрибута значения. Используя нативный атрибут значения и передавая локальное состояние в качестве значения, вы преобразуете неуправляемый компонент в контролируемый компонент.

{title="Code Playground",lang="javascript"}
~~~~~~~~
import React from 'react';

class Search extends React.Component {

  ...

  render() {
    return (
      <form onSubmit={this.onSubmit}>
        <input
# leanpub-start-insert
          value={this.state.query}
# leanpub-end-insert
          onChange={this.onChange}
          type="text"
        />
        <button type="submit">
          Search
        </button>
      </form>
    );
  }
}
~~~~~~~~

Теперь значение исходит от локального состояния как единственного источника правды. Он не может выйти из синхронизации с собственным состоянием узла DOM. Таким образом, вы также можете указать начальное состояние для состояния узла DOM. В противном случае попытайтесь получить начальное локальное состояние для `query` в вашем локальном состоянии, но не предоставляйте атрибут `value` для поля ввода. Ваше состояние было бы не синхронизировано в начале, потому что поле ввода было бы пустым, даже если в локальном состоянии компонента React есть что-то еще.

### Однонаправленный поток данных

В предыдущем примере вы увидели типичный однонаправленный поток данных. Архитектура Flux, лежащая в основе нескольких сложных решений для управления состоянием, таких как Redux, ввела термин **однонаправленный поток данных**. Вы узнаете больше об архитектуре Flux в следующей главе. Но сущность однонаправленного потока данных охватывает и локальное состояние в React. Состояние в React течет только в одном направлении. Состояние обновляется с помощью `this.setState ()` и отображается методом жизненного цикла `render()` путем доступа к `this.state`. И снова, он может быть обновлен с помощью `this.setState()`, и компонент будет перерисован.

В предыдущем примере, где вы использовали контролируемые компоненты, показан идеальный цикл однонаправленного потока данных. Поле ввода запускает обработчик `onChange` при изменении значения инпута. Обработчик изменяет локальное состояние. Измененное локальное состояние запускает жизненный цикл обновления компонента. Жизненный цикл обновления снова запускает метод жизненного цикла `render()`. Метод `render()` использует обновленное состояние. Состояние возвращается обратно в поле ввода, чтобы сделать его управляемым компонентом. Цикл замкнут. Новый цикл можно запустить, снова набрав что-то в поле ввода.

Однонаправленный поток данных делает управление состоянием предсказуемым и обслуживаемым. Лучшая практика уже распространилась на другие библиотеки состояний, библиотеки представления и решения SPA. В предыдущем поколении SPA чаще всего использовались другие механики. Например, в Angular 1.x вы бы использовали двустороннее связывание данных в архитектуре модель-представление-контроллер (MVC). Это означает, что как только вы изменили значение в представлении, скажем, в поле ввода, введя что-то, значение изменилось в контроллере. Но это сработало и наоборот. После того как вы изменили значение в контроллере программным способом, в представлении, чтобы быть более точным в поле ввода, отобразилось новое значение. Вы можете спросить: в чем проблема с этим подходом? Почему сейчас все используют однонаправленный поток данных вместо двунаправленного потока данных?

#### Однонаправленный vs. Двунаправленного поток данных

React охватывает однонаправленный поток данных. В прошлом фреймворки, такие как Angular 1.x, охватывали двунаправленный поток данных. Это было известно как двусторонняя привязка данных. Это была одна из причин, по которой Angular был популярен в первую очередь. Но и в этой конкретной области это не удалось. Особенно, на мой взгляд, именно этот недостаток заставил многих людей перейти на React. Но на данный момент я не хочу быть слишком самоуверенным. Так почему же двунаправленный поток данных потерпел неудачу? Почему все принимают однонаправленный поток данных?

Тремя преимуществами однонаправленного потока данных над двунаправленным потоком данных являются предсказуемость, удобство обслуживания и производительность.

**Предсказуемость**: в масштабирующем приложении управление состоянием должно оставаться предсказуемым. Когда вы изменяете свое состояние, должно быть ясно, какие компоненты заботятся об этом. Также должно быть понятно, кто в первую очередь меняет состояние. В однонаправленном потоке данных один участник изменяет состояние, состояние сохраняется, и состояние передается из одного места, например, компонента с состоянием, ко всем дочерним компонентам, которые заинтересованы в этом состоянии.

**Поддерживаемость:** При совместной работе в команде над масштабируемым приложением одним из требований управления состоянием является предсказуемость. Люди не способны отслеживать растущий двунаправленный поток данных. Это ограничение по природе. Вот почему управление состоянием остается более управляемым, пока оно предсказуемо. В противном случае, когда люди не могут основываться на состоянии, они вводят неэффективное управление состоянием. Но поддерживаемость не обходится без затрат в однонаправленном потоке данных. Хотя состояние предсказуемо, его часто необходимо тщательно продумать. В следующей главе вы прочтете об этих рефакторингах, таких как поднятие состояния или компоненты более высокого порядка для локального состояния.

**Производительность:** В однонаправленном потоке данных состояние передается по дереву компонентов. Все компоненты, зависящие от состояния, имеют возможность повторного рендеринга. В отличие от двунаправленного потока данных, где не всегда ясно, кто должен обновляться в соответствии с изменениями состояния. Состояние течет в слишком многих направлениях. Слой модели зависит от слоя представления, а слой представления зависит от слоя модели. Это обратная зависимость, которая приводит к проблемам с производительностью в жизненном цикле обновления.

Эти три преимущества демонстрируют превосходство использования однонаправленного потока данных над двунаправленным потоком данных. Вот почему в наши дни так много решений для управления состоянием и SPA решения процветают в отличии от предшественников.
