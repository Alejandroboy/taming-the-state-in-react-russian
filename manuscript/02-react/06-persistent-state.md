## Постоянство в состоянии

Состояние в приложениях часто не является постоянным. Когда ваше приложение запускается, часто существует начальное состояние, но нет базы данных для воссоздания состояния из предыдущего сеанса. Однако в вашем приложении состояние обновляется, когда пользователь взаимодействует с приложением (локальные данные) или данные поступают из бэкенда приложения (удаленные данные). Вы можете задаться вопросом, существует ли способ сохранить состояние, чтобы его можно было использовать в качестве начального состояния при повторном запуске приложения. Этот вопрос относится как к локальному управлению состоянием, так и к сложному управлению состоянием в дальнейшем.

Очевидным ответом на этот вопрос будет реализация бэкенд приложения с базой данных для сохранения состояния. Извлечение состояния из вашего бэкенд приложения называется **обезвоживанием состояния**. Теперь каждый раз, когда ваше приложение запускается снова, вы извлекаете состояние из бэкенд 
 приложения. Как только состояние приходит в ответе асинхронно, вы **наполняете состояние** в свое приложение. Вот как вы бы достигните начального состояния приложения из постоянной базы данных.

Хотя обезвоживание состояния может происходить в любое время, когда ваше приложение работает, возможно, когда пользователь взаимодействует с вашим приложением, повторное наполнение состояния будет происходить, когда ваши компоненты монтируются при запуске приложения. Лучшее место для этого в React - метод жизненного цикла `componentDidMount()`. Возьмем, к примеру, компонент `ArchiveableList` из предыдущей главы. Он может извлечь все заархивированные уникальные идентификаторы элементов в `componentDidMount()` из вашего бэкэнд-приложения и перевести их в локальное состояние.

{title="Code Playground",lang="javascript"}
~~~~~~~~
import React from 'react';

class ArchiveableList extends React.Component {
  constructor(props) {
    ...
  }

  onArchive(id) {
    ...
  }

  componentDidMount() {
    fetch('path/to/archived/items')
      .then(response => response.json())
      .then(archivedItems => this.setState(rehydrateArchivedItems(archivedItems)));
  }

  render() {
    ...
  }
}

function rehydrateArchivedItems(archivedItems) {
  return function(prevState) {
    return {
      archivedItems: [
        ...prevState.archivedItems,
        ...archivedItems
      ]
    };
  };
}
~~~~~~~~

Теперь, каждый раз, когда компонент инициализируется, постоянные заархивированные элементы будут использоваться в качестве начального состояния для вашего компонента. Фактически, начальное состояние определяется в конструкторе компонента, но после того, как компонент подключен, он получает следующее состояние из бэкэнд-приложения и наполняет им исходное состояние.

С другой стороны, обезвоживание может произойти в любое время, но во избежание несоответствий, например, в случае заархивированных элементов, обезвоживание будет иметь место, когда элемент заархивирован. Это обычный запрос к бэкэнду сохранить элемент в архиве.

Напонение и обезвоживание состояния чаще всего являются бессознательными шагами в современных приложениях. Разумно получать все необходимые данные из бэкэнда при запуске приложения и обновлять данные, когда что-то изменилось. Но вам следует помнить о напонение и обезвоживание состояния, чтобы синхронизировать состояние приложения с данными бэкэнда в качестве единственного источника правды.

### Локальное хранилище

Вы можете спросить, есть ли более легкое решение по сравнению с бэкэнд-приложением? Да, есть: вы могли бы использовать нативный API браузера. Чтобы быть более конкретным, большинство современных браузеров имеют функцию хранения для сохранения данных. Это облегченная версия базы данных, которая используется в браузере. Конечно, он виден только пользователю браузера и не может быть распространен среди других пользователей. И как только пользователи очищают данные своего браузера, очищается и магазин. Таким образом, в действительности данные не являются полностью постоянными, но, по крайней мере, могут использоваться между сеансами браузера.

Современные браузеры имеют доступ к [локальному хранилищу](https://developer.mozilla.org/en/docs/Web/API/Window/localStorage) и [хранилищу сеансов](https://developer.mozilla.org/en/docs/Web/API/Window/sessionStorage). Оба работают одинаково, но есть одно различие в их функциональности. Локальное хранилище хранит данные, даже когда браузер закрыт, срок хранения сеанса истекает после закрытия браузера. Оба хранилища работают одинаково, используя пары ключ-значение.

{title="Code Playground",lang="javascript"}
~~~~~~~~
// Save data to localStorage
localStorage.setItem('key', 'value');

// Get saved data from localStorage
var data = localStorage.getItem('key');

// Remove saved data from localStorage
localStorage.removeItem('key');

// Remove all saved data from localStorage
localStorage.clear();
~~~~~~~~

Вы можете применить их так же, как вы делали это в предыдущем компоненте `ArchiveableList`, который использовал запрос к бэкэнд-приложению для извлечения данных. Теперь компонент `ArchiveableList` будет использовать хранилище вместо бэкэнда для получения состояния. Если вы заинтересованы в изучении использования локального хранилища в React, вы можете прочитать больше об этом в этой статье: [Как использовать локальное хранилище в React](https://www.robinwieruch.de/local-storage-react/).

### Кэширование состояния

Локальное состояние, а затем и сложное состояние, можно использовать в качестве кэша для вашего приложения. Кэш будет делать повторяющиеся запросы на получение данных из бэкэнда избыточными, потому что они будут возвращать те же данные, что и раньше, и данные уже закэшированны в состоянии.

Представьте, что ваше приложение имеет интерфейс для поиска популярных историй на новостной платформе. Новостная платформа имеет открытый API, который вы можете использовать для получения этих популярных историй. Ваше собственное приложение, которое использует API этой платформы, будет иметь только поле поиска для поиска популярных историй с платформы и список для отображения историй после того, как вы их искали.

Затем представьте, что вы сделали свой первый запрос в поиске популярных историй о «React». Вы не удовлетворены результатом поиска, потому что вы хотели быть более конкретным, и выполните поиск снова «React Local State». Вы все еще не удовлетворительны результатами поиска, но результат поиска для «React Local State» отображается в вашем приложении. Затем вы хотите вернуться к результату поиска «React». Ваше приложение отправляет третий запрос на получение «React» историй к стороннему API. В идеальном мире приложение будет знать, что вы уже искали истории "React" ранее. Вот где кеширование вступает в игру. Третий запрос можно было бы избежать, если бы приложение кэшировало результаты поиска.

Такое решение с изменяющимся кэшем не слишком сложно реализовать с локальным состоянием. Имейте в виду, что он будет работать со сложным решением для управления состоянием, таким как Redux или MobX. При поиске историй у вас уже есть уникальный идентификатор, который вы можете использовать в качестве ключа в объекте для сохранения результатов поиска в локальном состоянии. Уникальный идентификатор - это ваш поисковый запрос. Это будет либо «React», либо «React Local State» с учетом предыдущего примера. Значение, соответствующее ключу, будет результатом поиска. В этом примере это будут популярные истории о «React» и «React Local Storage». В конце концов, ваш объект кеша в локальном состоянии может быть похож на это:

{title="Code Playground",lang="javascript"}
~~~~~~~~
this.state = {
  ...
  searchCache: {
    React: [...],
    ReactLocalState: [...],
  }
}
~~~~~~~~

Каждый раз, когда ваше приложение выполняет поисковый запрос, пара ключа-значение в объекте кэша в вашем локальном состоянии будет записанна. Перед тем, как сделать новый запрос, кэш будет проверен, доступен ли поисковый запрос в качестве ключа в объекте. Если ключ доступен, запрос будет пресечен, и вместо него будет использован результат кэширования. Если ключ недоступен, запрос будет сделан. После успешного выполнения запроса условие поиска будет сохранено как ключ, а результат поиска будет сохранен как значение в локальном состоянии.

Книга не даст вам углубленного понимания реализации кеш-решения. Если вы прочитали [Путь к изучению React](https://www.robinwieruch.de/the-road-to-learn-react/), вы уже знаете, как реализовать такой кэш в простом React с локальным состоянием. В одном из своих уроков книга использует кэш более детально, чтобы эффективно кэшировать даже постраничные результаты поиска в локальном состоянии. Так что, если вам это интересно, закажите книгу «Путь к изучению React» снова.]