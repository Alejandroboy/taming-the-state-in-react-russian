## Переход к сложному состоянию

By now you have learned about the basics in local state management and how to scale it in a growing application with a variety of techniques and best practices. These learnings should give you a great surface area to apply them in your applications to scale state management without using a sophisticated state management library and by only using local state. So what's next in this book? The following chapters will give you a transition from local state management to sophisticated state management.
К настоящему времени вы узнали об основах управления локальными состояниями и о том, как масштабировать их в растущем приложении с помощью различных методов и лучших практик. Эти уроки должны дать вам большую площадь для применения их в ваших приложениях для масштабирования управления состояниями без использования сложной библиотеки управления состоянием и только с использованием локального состояния. Так что же дальше в этой книге? В следующих главах вы перейдете от локального управления состояниями к сложному управлению состоянием.

### Противоречия управления локальным состоянием

State management is a controversial topic. You will find a ton of discussions and opinions around it. You will find it as recurring topic not only in React, but also in other SPA or view layer solutions for modern web applications. The book is my attempt to give you consistency for these opinions and enable you to learn state management step by step.
Управление состоянием является спорным вопросом. Вы найдете массу дискуссий и мнений по этому поводу. Вы найдете его в качестве повторяющейся темы не только в React, но и в других решениях SPA или уровне представления для современных веб-приложений. Книга - моя попытка дать вам последовательность этих мнений и дать вам возможность шаг за шагом научиться управлению состоянием.

The following statement is controversial: *The local state in React is sufficient for most of your application. You will not need a sophisticated state management solutions like Redux or MobX.*

Следующее утверждение является спорным: *Локального состояния в React достаточно для большинства ваших приложений. Вам не понадобятся сложные решения для управления состоянием, такие как Redux или MobX.*

Personally, I agree with the statement. You can build quite large applications with only local state management. You should be aware of best practices and patterns to scale it, as you have learned them in the previous chapters, but it is doable. You can spare a lot of application complexity by using plain local state. Once your application scales, you might want to consider using a sophisticated state management library at some point.
Лично я согласен с утверждением. Вы можете создавать довольно большие приложения только с локальным управлением состояниями. Вы должны знать о лучших практиках и шаблонах для их масштабирования, как вы узнали их в предыдущих главах, но это выполнимо. Вы можете уменьшить сложность приложения, используя простое локальное состояние. Как только ваше приложение масштабируется, вы можете захотеть использовать сложную библиотеку управления состоянием в какой-то момент.

The next statement might be controversial, too: *Once you have a sophisticated state management library in place, you shouldn't use local state anymore.*
Следующее утверждение также может быть спорным: *Если у вас есть сложная библиотека управления состоянием, вам больше не следует использовать локальное состояние.*

Personally, I strongly disagree with the statement. Not every state should live in a sophisticated state management. There are many use cases when local state is applicable in large applications. Especially when considering entity state and view state: The view state can most often live in a local state, because it is not shared widely across the application. But the entity state most likely lives in a sophisticated state, because it is shared across multiple components. It might need to be accessible and modifiable by multiple components across your application.
Лично я категорически не согласен с заявлением. Не каждое состояние должно жить в сложном управлении состоянием. Есть много случаев использования, когда локальное состояние применимо в больших приложениях. Особенно при рассмотрении состояния объекта и состояния просмотра. Состояние просмотра чаще всего может существовать в локальном состоянии, поскольку оно не распределяется между несколькими компонентами в приложении. Но состояние объекта, скорее всего, живет в сложном состоянии, потому что оно распределяется между несколькими компонентами. Возможно, он должен быть доступен и модифицирован несколькими компонентами в вашем приложении.

Last but not least, another controversial statement: *You don't need React's local state, you can learn Redux instead altogether with React.*
Последнее, но не по значению, спорное утверждение: *Вам не нужно локальное состояние React, вы можете изучать Redux вмест с React*.

I strongly disagree with the statement, too. If you want to develop applications with React, you should certainly be aware of local state in React. You should have built applications with it before you start to learn and apply sophisticated state management solutions. You need to run into local state management problems before you get the help of sophisticated state management solutions. You will always need local state management, even for large applications.
Я также категорически не согласен с этим утверждением. Если вы хотите разрабатывать приложения с помощью React, вам обязательно следует знать о локальном состоянии в React. Вы должны создать приложения с ним, прежде чем начать изучать и применять сложные решения по управлению состоянием. Вы должны столкнуться с локальными проблемами управления состоянием, прежде чем вы получите помощь сложных решений для управления состоянием. Вам всегда потребуется локальное управление состоянием, даже для больших приложений.

These were only three controversial statements. But there are way more opinions around the topic. In the end, you should make your own experiences to get to know what makes sense to you. However, if you are transitioning from plain React to React + Redux or React + Redux, I highly recommend reading this article before continuing reading the book: [Things to learn in React before using Redux](https://www.robinwieruch.de/learn-react-before-using-redux/).
Это были только три спорных утверждения. Но есть много мнений по этой теме. В конце концов, вы должны получить собственный опыт, чтобы узнать, что имеет для вас смысл. Однако, если вы переходите от простого React к React + Redux или React + Redux, я настоятельно рекомендую прочитать эту статью, прежде чем продолжить чтение книги: [Что нужно изучить в React перед использованием Redux](https://www.robinwieruch.de/learn-react-before-using-redux/).

### Недостатки локального управления сосстоянием

In order to come to a conclusion of local state management, there is one open question: What's the problem with local state management? Developers wonder why they need sophisticated state management in order to tame their state. In other scenarios, people never wonder about it, because they have learned sophisticated state management from the beginning without using local state. That might not be the best approach in the first place, because you have to experience a problem before you use a solution for it. You can't skip the problem and use the solution right away.
Чтобы прийти к заключению о локальном управлении состоянием, есть один открытый вопрос: в чем проблема с локальным управлением состоянием? Разработчики задаются вопросом, зачем им нужно сложное управление состоянием, чтобы приручить свое состояние. В других сценариях люди никогда не задумываются об этом, потому что они научились сложному управлению состояниями с самого начала, не используя локальное состояние. Во-первых, это может быть не лучшим подходом, потому что вы должны столкнуться с проблемой, прежде чем использовать ее решение. Вы не можете пропустить проблему и использовать решение сразу.

So what's the problem with using only local state management? It doesn't scale in large applications. It doesn't scale implementation-wise, but it локального управления состоянием? Оно не масштабируется в больших приложениях. Оно не масштабируется с точки зрения реализации, и, вероятно, не масштабируется и в команде разработчиков.

Implementation-wise it doesn't scale because too many components across your application share state. They need to access the state, need to modify it or need to remove it. In a small application, these components are not far away from each other. You can apply best practices like lifting state up and down to keep the state management maintainable. At some point, components are too far away from each other. The state needs to be lifted the component tree all the way up. Still, child components could be multiple levels below the stateful component. The state would creep through all components in between even though these components don't need access to it. That's there you may want to consider React's context API, but it shouldn't replace your whole state management architecture.
С точки зрения реализации, он не масштабируется, потому что слишком много компонентов в вашем общем состоянии приложения. Им необходимо получить доступ к состоянию, изменить его или удалить его. В небольшом приложении эти компоненты находятся недалеко друг от друга. Вы можете применять лучшие практики, такие как поднятие и опускание состояния, чтобы поддерживать управление состоянием. В какой-то момент компоненты находятся слишком далеко друг от друга. Необходимо полностью поднять состояние дерева компонентов. Тем не менее, дочерние компоненты могут быть на несколько уровней ниже компонента с состоянием. Состояние проползет через все промежуточные компоненты, даже если эти компоненты не нуждаются в доступе к нему. Вот здесь вы можете рассмотреть контекстный API React, но он не должен заменить всю вашу архитектуру управления состоянием.

Local state can become unmaintainable. It is already difficult for one person to keep the places in mind where local state is used in the component tree. When a team of developers implements one application, it becomes even more difficult to keep track of it. Usually it is not necessary to keep track about the local state. In a perfect world, everyone would lift state up and down to keep it maintainable. In the real world, code doesn't get refactored as often as it should be. The state creeps through all components even though they don't consume it.
Локальное состояние может стать неуправляемым. Одному человеку уже трудно помнить места, в которых локальное состояние используется в дереве компонентов. Когда команда разработчиков реализует одно приложение, становится еще сложнее отслеживать его. Обычно нет необходимости отслеживать локальное состояние. В идеальном мире каждый компонент поднимает и опускает состояние, чтобы поддерживать его в рабочем состоянии. В реальном мире код не подвергается рефакторингу так часто, как следовало бы. Состояние проползает по всем компонентам, даже если они его не потребляют.

One could argue that the issues of maintainability apply for sophisticated state as well. That's true, there are pitfalls again that people need to avoid to keep the state management maintainable. For instance, not every component should know about the global state. However, at least the state management is gathered at one place, in a global state, to maintain it. It doesn't get too mixed up with the view layer. There are only bridges that connect the view layer with the state layer. Thus it is a wise decision to apply sophisticated state management in larger applications in order to tame the state. So let's get into it!
Можно утверждать, что вопросы поддерживаемости применимы и к сложному состоянию. Это правда, которых есть подводные камни, которых люди должны избегать, чтобы сохранить управление состоянием поддерживаемым. Например, не каждый компонент должен знать о глобальном состоянии. Однако, по крайней мере, управление состоянием собрано в одном месте, в глобальном состоянии, чтобы поддерживать его. Оно не смешивается со слоем вида. Есть только мосты, которые связывают слой представления со слоем состояния. Таким образом, применение сложного управления состоянием в больших приложениях, чтобы укротить состояние является мудрым решением. Итак, давайте углубимся!